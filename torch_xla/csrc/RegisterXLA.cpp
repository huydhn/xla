// required for old g++ to compile PRId64 macros, see
// https://github.com/pytorch/pytorch/issues/3571
// for context
#ifndef __STDC_FORMAT_MACROS
#define __STDC_FORMAT_MACROS
#endif

// an external backend might generate file within its code tree
// and check all the source files within the tree with clang-format.
// so, disable it since the backend might have a different config.
// clang-format off

// NOTE: This condition is true for all PyTorch internal libraries, it
//       just excludes external projects such as torch_xla which
//       re-use some of the PyTorch codegen machinery.
#if defined(CAFFE2_BUILD_MAIN_LIB)        || \
    defined(TORCH_CUDA_BUILD_MAIN_LIB)    || \
    defined(TORCH_HIP_BUILD_MAIN_LIB)     || \
    defined(TORCH_CUDA_CU_BUILD_MAIN_LIB) || \
    defined(TORCH_CUDA_CPP_BUILD_MAIN_LIB)
#define TORCH_ASSERT_ONLY_METHOD_OPERATORS
#endif

// @generated by torchgen/gen.py from RegisterDispatchKey.cpp

#include <c10/core/TensorImpl.h>
#include <c10/core/Allocator.h>
#include <ATen/DeviceGuard.h>
#include <ATen/NamedTensorUtils.h>
#include <ATen/Utils.h>
#include <ATen/WrapDimUtils.h>
#include <ATen/Dispatch.h>
#include <c10/util/ExclusivelyOwned.h>
#include <c10/util/Half.h>
#include <c10/core/UndefinedTensorImpl.h>
#include <c10/util/Optional.h>
#include <ATen/Tensor.h>
#include <ATen/native/Resize.h>

#include <cstddef>
#include <functional>
#include <memory>
#include <utility>

#include <ATen/Config.h>
#include <ATen/core/op_registration/adaption.h>
#include <torch/library.h>

#include "/usr/local/google/home/miladmo/sw/dupe/pytorch/xla/scripts/../torch_xla/csrc/XLANativeFunctions.h"
#include <ATen/NativeFunctions.h>
#include <ATen/Functions.h>
#include <ATen/Functions.h>


namespace at {

// NB: TORCH_LIBRARY_IMPL must be in an anonymous namespace to avoid
// ambiguity with conflicting identifiers that may have been defined in
// at namespace already.
namespace {


void resize_out(const Tensor &out, IntArrayRef sizes, IntArrayRef strides, const TensorOptions &options) {
  TORCH_CHECK(options.dtype() == out.dtype(),
      "Expected out tensor to have dtype ", options.dtype(), ", but got ", out.dtype(), " instead");
  TORCH_CHECK(options.device() == out.device(),
      "Expected out tensor to have device ", options.device(), ", but got ", out.device(), " instead");
  const bool resized = at::native::resize_output(out, sizes);
  // Only restride if a resize occurred; otherwise we ignore the (advisory)
  // strides from the meta function and directly use the output tensor's
  // preexisting strides
  if (resized) {
    if (!strides.empty()) {
      TORCH_INTERNAL_ASSERT(!options.memory_format_opt().has_value());
      at::native::as_strided_(out, sizes, strides);
    } else if (options.memory_format_opt().has_value()) {
      out.unsafeGetTensorImpl()->empty_tensor_restride(*options.memory_format_opt());
    }
  }
}

void check_inplace(const Tensor &self, IntArrayRef sizes, const TensorOptions &options) {
  // These checks are needed on those operators that:
  //   1) don't use 'TensorIterator' (e.g. 'addmm' and 'baddbmm')
  //   2) have particular typing rules (e.g. 'cumsum' and 'cumprod')
  // For other operators (e.g. 'add'), 'TensorIterator' already checks
  // these things separately.
  TORCH_CHECK(options.dtype() == self.dtype(),
      "Bad in-place call: ",
      "input tensor dtype ", self.dtype(), " and output tensor dtype ", options.dtype(), " should match");
  TORCH_CHECK(options.device() == self.device(),
      "Bad in-place call: ",
      "input tensor device ", self.device(), " and output tensor device ", options.device(), " should match");
  TORCH_CHECK(sizes == self.sizes(),
      "Bad in-place call: ",
      "input tensor size ", self.sizes(), " and output tensor size ", sizes, " should match");
}

namespace {

at::Tensor wrapper__abs(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::abs(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_abs_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_abs_out_tmp = wrapper__abs(self);
  at::_copy_from_and_resize(wrapper_out_abs_out_tmp, out);
  return out;
}
at::Tensor & wrapper__abs_(at::Tensor & self) {
  auto wrapper__abs__tmp = wrapper__abs(self);
  at::_copy_from(wrapper__abs__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__sgn(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sgn(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_sgn_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_sgn_out_tmp = wrapper__sgn(self);
  at::_copy_from_and_resize(wrapper_out_sgn_out_tmp, out);
  return out;
}
at::Tensor & wrapper__sgn_(at::Tensor & self) {
  auto wrapper__sgn__tmp = wrapper__sgn(self);
  at::_copy_from(wrapper__sgn__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__acos(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::acos(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_acos_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_acos_out_tmp = wrapper__acos(self);
  at::_copy_from_and_resize(wrapper_out_acos_out_tmp, out);
  return out;
}
at::Tensor & wrapper__acos_(at::Tensor & self) {
  auto wrapper__acos__tmp = wrapper__acos(self);
  at::_copy_from(wrapper__acos__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_add(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::add(self, other, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_out_add_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_out_add_out_tmp = wrapper_Tensor_add(self, other, alpha);
  at::_copy_from_and_resize(wrapper_out_add_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_add_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  auto wrapper_Tensor_add__tmp = wrapper_Tensor_add(self, other, alpha);
  at::_copy_from(wrapper_Tensor_add__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_add(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::add(self, other, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_add_out(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_Scalar_out_add_out_tmp = wrapper_Scalar_add(self, other, alpha);
  at::_copy_from_and_resize(wrapper_Scalar_out_add_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_add_(at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
  auto wrapper_Scalar_add__tmp = wrapper_Scalar_add(self, other, alpha);
  at::_copy_from(wrapper_Scalar_add__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_dim_all(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::all(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_all_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_all_out_tmp = wrapper_dim_all(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_all_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_dim_any(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::any(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_any_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_any_out_tmp = wrapper_dim_any(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_any_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper_start_out_arange_out(const at::Scalar & start, const at::Scalar & end, const at::Scalar & step, at::Tensor & out) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::arange_out(start, end, step, out);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__argmax(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::argmax(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_argmax_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_argmax_out_tmp = wrapper__argmax(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_argmax_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__argmin(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::argmin(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_argmin_out(const at::Tensor & self, c10::optional<int64_t> dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_argmin_out_tmp = wrapper__argmin(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_argmin_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__acosh(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::acosh(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_acosh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_acosh_out_tmp = wrapper__acosh(self);
  at::_copy_from_and_resize(wrapper_out_acosh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__acosh_(at::Tensor & self) {
  auto wrapper__acosh__tmp = wrapper__acosh(self);
  at::_copy_from(wrapper__acosh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__asinh(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::asinh(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_asinh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_asinh_out_tmp = wrapper__asinh(self);
  at::_copy_from_and_resize(wrapper_out_asinh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__asinh_(at::Tensor & self) {
  auto wrapper__asinh__tmp = wrapper__asinh(self);
  at::_copy_from(wrapper__asinh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__atanh(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::atanh(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_atanh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_atanh_out_tmp = wrapper__atanh(self);
  at::_copy_from_and_resize(wrapper_out_atanh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__atanh_(at::Tensor & self) {
  auto wrapper__atanh__tmp = wrapper__atanh(self);
  at::_copy_from(wrapper__atanh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__as_strided(const at::Tensor & self, at::IntArrayRef size, at::IntArrayRef stride, c10::optional<int64_t> storage_offset) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::as_strided(self, size, stride, storage_offset);
}

} // anonymous namespace
namespace {

const at::Tensor & wrapper__as_strided_(const at::Tensor & self, at::IntArrayRef size, at::IntArrayRef stride, c10::optional<int64_t> storage_offset) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::as_strided_(self, size, stride, storage_offset);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__asin(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::asin(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_asin_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_asin_out_tmp = wrapper__asin(self);
  at::_copy_from_and_resize(wrapper_out_asin_out_tmp, out);
  return out;
}
at::Tensor & wrapper__asin_(at::Tensor & self) {
  auto wrapper__asin__tmp = wrapper__asin(self);
  at::_copy_from(wrapper__asin__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__atan(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::atan(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_atan_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_atan_out_tmp = wrapper__atan(self);
  at::_copy_from_and_resize(wrapper_out_atan_out_tmp, out);
  return out;
}
at::Tensor & wrapper__atan_(at::Tensor & self) {
  auto wrapper__atan__tmp = wrapper__atan(self);
  at::_copy_from(wrapper__atan__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__baddbmm(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::baddbmm(self, batch1, batch2, beta, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_out_baddbmm_out(const at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_out_baddbmm_out_tmp = wrapper__baddbmm(self, batch1, batch2, beta, alpha);
  at::_copy_from_and_resize(wrapper_out_baddbmm_out_tmp, out);
  return out;
}
at::Tensor & wrapper__baddbmm_(at::Tensor & self, const at::Tensor & batch1, const at::Tensor & batch2, const at::Scalar & beta, const at::Scalar & alpha) {
  auto wrapper__baddbmm__tmp = wrapper__baddbmm(self, batch1, batch2, beta, alpha);
  at::_copy_from(wrapper__baddbmm__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__bernoulli(const at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bernoulli(self, generator);
}

} // anonymous namespace
at::Tensor & wrapper_out_bernoulli_out(const at::Tensor & self, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_out_bernoulli_out_tmp = wrapper__bernoulli(self, generator);
  at::_copy_from_and_resize(wrapper_out_bernoulli_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper_Tensor_bernoulli_(at::Tensor & self, const at::Tensor & p, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bernoulli_(self, p, generator);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_float_bernoulli_(at::Tensor & self, double p, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bernoulli_(self, p, generator);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__binary_cross_entropy(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::binary_cross_entropy(self, target, weight, reduction);
}

} // anonymous namespace
at::Tensor & wrapper_out_binary_cross_entropy_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & out) {
  auto wrapper_out_binary_cross_entropy_out_tmp = wrapper__binary_cross_entropy(self, target, weight, reduction);
  at::_copy_from_and_resize(wrapper_out_binary_cross_entropy_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__binary_cross_entropy_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::binary_cross_entropy_backward(grad_output, self, target, weight, reduction);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_binary_cross_entropy_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, at::Tensor & grad_input) {
  auto wrapper_grad_input_binary_cross_entropy_backward_out_tmp = wrapper__binary_cross_entropy_backward(grad_output, self, target, weight, reduction);
  at::_copy_from_and_resize(wrapper_grad_input_binary_cross_entropy_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__binary_cross_entropy_with_logits(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & pos_weight, int64_t reduction) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::binary_cross_entropy_with_logits(self, target, weight, pos_weight, reduction);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__bitwise_not(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_not(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_bitwise_not_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_bitwise_not_out_tmp = wrapper__bitwise_not(self);
  at::_copy_from_and_resize(wrapper_out_bitwise_not_out_tmp, out);
  return out;
}
at::Tensor & wrapper__bitwise_not_(at::Tensor & self) {
  auto wrapper__bitwise_not__tmp = wrapper__bitwise_not(self);
  at::_copy_from(wrapper__bitwise_not__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__logical_not(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::logical_not(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_logical_not_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_logical_not_out_tmp = wrapper__logical_not(self);
  at::_copy_from_and_resize(wrapper_out_logical_not_out_tmp, out);
  return out;
}
at::Tensor & wrapper__logical_not_(at::Tensor & self) {
  auto wrapper__logical_not__tmp = wrapper__logical_not(self);
  at::_copy_from(wrapper__logical_not__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__logical_xor(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::logical_xor(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_logical_xor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_logical_xor_out_tmp = wrapper__logical_xor(self, other);
  at::_copy_from_and_resize(wrapper_out_logical_xor_out_tmp, out);
  return out;
}
at::Tensor & wrapper__logical_xor_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper__logical_xor__tmp = wrapper__logical_xor(self, other);
  at::_copy_from(wrapper__logical_xor__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__logical_and(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::logical_and(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_logical_and_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_logical_and_out_tmp = wrapper__logical_and(self, other);
  at::_copy_from_and_resize(wrapper_out_logical_and_out_tmp, out);
  return out;
}
at::Tensor & wrapper__logical_and_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper__logical_and__tmp = wrapper__logical_and(self, other);
  at::_copy_from(wrapper__logical_and__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__logical_or(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::logical_or(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_logical_or_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_logical_or_out_tmp = wrapper__logical_or(self, other);
  at::_copy_from_and_resize(wrapper_out_logical_or_out_tmp, out);
  return out;
}
at::Tensor & wrapper__logical_or_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper__logical_or__tmp = wrapper__logical_or(self, other);
  at::_copy_from(wrapper__logical_or__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__bmm(const at::Tensor & self, const at::Tensor & mat2) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bmm(self, mat2);
}

} // anonymous namespace
at::Tensor & wrapper_out_bmm_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
  auto wrapper_out_bmm_out_tmp = wrapper__bmm(self, mat2);
  at::_copy_from_and_resize(wrapper_out_bmm_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__cat(at::TensorList tensors, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cat(tensors, dim);
}

} // anonymous namespace
at::Tensor & wrapper_out_cat_out(at::TensorList tensors, int64_t dim, at::Tensor & out) {
  auto wrapper_out_cat_out_tmp = wrapper__cat(tensors, dim);
  at::_copy_from_and_resize(wrapper_out_cat_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__ceil(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::ceil(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_ceil_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_ceil_out_tmp = wrapper__ceil(self);
  at::_copy_from_and_resize(wrapper_out_ceil_out_tmp, out);
  return out;
}
at::Tensor & wrapper__ceil_(at::Tensor & self) {
  auto wrapper__ceil__tmp = wrapper__ceil(self);
  at::_copy_from(wrapper__ceil__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__clamp(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clamp(self, min, max);
}

} // anonymous namespace
at::Tensor & wrapper_out_clamp_out(const at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max, at::Tensor & out) {
  auto wrapper_out_clamp_out_tmp = wrapper__clamp(self, min, max);
  at::_copy_from_and_resize(wrapper_out_clamp_out_tmp, out);
  return out;
}
at::Tensor & wrapper__clamp_(at::Tensor & self, const c10::optional<at::Scalar> & min, const c10::optional<at::Scalar> & max) {
  auto wrapper__clamp__tmp = wrapper__clamp(self, min, max);
  at::_copy_from(wrapper__clamp__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_clamp(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clamp(self, min, max);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_clamp_out(const at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max, at::Tensor & out) {
  auto wrapper_Tensor_out_clamp_out_tmp = wrapper_Tensor_clamp(self, min, max);
  at::_copy_from_and_resize(wrapper_Tensor_out_clamp_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_clamp_(at::Tensor & self, const c10::optional<at::Tensor> & min, const c10::optional<at::Tensor> & max) {
  auto wrapper_Tensor_clamp__tmp = wrapper_Tensor_clamp(self, min, max);
  at::_copy_from(wrapper_Tensor_clamp__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__clamp_max(const at::Tensor & self, const at::Scalar & max) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clamp_max(self, max);
}

} // anonymous namespace
at::Tensor & wrapper_out_clamp_max_out(const at::Tensor & self, const at::Scalar & max, at::Tensor & out) {
  auto wrapper_out_clamp_max_out_tmp = wrapper__clamp_max(self, max);
  at::_copy_from_and_resize(wrapper_out_clamp_max_out_tmp, out);
  return out;
}
at::Tensor & wrapper__clamp_max_(at::Tensor & self, const at::Scalar & max) {
  auto wrapper__clamp_max__tmp = wrapper__clamp_max(self, max);
  at::_copy_from(wrapper__clamp_max__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_clamp_max(const at::Tensor & self, const at::Tensor & max) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clamp_max(self, max);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_clamp_max_out(const at::Tensor & self, const at::Tensor & max, at::Tensor & out) {
  auto wrapper_Tensor_out_clamp_max_out_tmp = wrapper_Tensor_clamp_max(self, max);
  at::_copy_from_and_resize(wrapper_Tensor_out_clamp_max_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_clamp_max_(at::Tensor & self, const at::Tensor & max) {
  auto wrapper_Tensor_clamp_max__tmp = wrapper_Tensor_clamp_max(self, max);
  at::_copy_from(wrapper_Tensor_clamp_max__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__clamp_min(const at::Tensor & self, const at::Scalar & min) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clamp_min(self, min);
}

} // anonymous namespace
at::Tensor & wrapper_out_clamp_min_out(const at::Tensor & self, const at::Scalar & min, at::Tensor & out) {
  auto wrapper_out_clamp_min_out_tmp = wrapper__clamp_min(self, min);
  at::_copy_from_and_resize(wrapper_out_clamp_min_out_tmp, out);
  return out;
}
at::Tensor & wrapper__clamp_min_(at::Tensor & self, const at::Scalar & min) {
  auto wrapper__clamp_min__tmp = wrapper__clamp_min(self, min);
  at::_copy_from(wrapper__clamp_min__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_clamp_min(const at::Tensor & self, const at::Tensor & min) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clamp_min(self, min);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_clamp_min_out(const at::Tensor & self, const at::Tensor & min, at::Tensor & out) {
  auto wrapper_Tensor_out_clamp_min_out_tmp = wrapper_Tensor_clamp_min(self, min);
  at::_copy_from_and_resize(wrapper_Tensor_out_clamp_min_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_clamp_min_(at::Tensor & self, const at::Tensor & min) {
  auto wrapper_Tensor_clamp_min__tmp = wrapper_Tensor_clamp_min(self, min);
  at::_copy_from(wrapper_Tensor_clamp_min__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__constant_pad_nd(const at::Tensor & self, at::IntArrayRef pad, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::constant_pad_nd(self, pad, value);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__convolution_overrideable(const at::Tensor & input, const at::Tensor & weight, const c10::optional<at::Tensor> & bias, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool transposed, at::IntArrayRef output_padding, int64_t groups) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::convolution_overrideable(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper__convolution_backward_overrideable(const at::Tensor & grad_output, const at::Tensor & input, const at::Tensor & weight, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool transposed, at::IntArrayRef output_padding, int64_t groups, ::std::array<bool,3> output_mask) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::convolution_backward_overrideable(grad_output, input, weight, stride, padding, dilation, transposed, output_padding, groups, output_mask);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___copy_from(const at::Tensor & self, const at::Tensor & dst, bool non_blocking) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_copy_from(self, dst, non_blocking);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___copy_from_and_resize(const at::Tensor & self, const at::Tensor & dst) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_copy_from_and_resize(self, dst);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__cos(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cos(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_cos_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_cos_out_tmp = wrapper__cos(self);
  at::_copy_from_and_resize(wrapper_out_cos_out_tmp, out);
  return out;
}
at::Tensor & wrapper__cos_(at::Tensor & self) {
  auto wrapper__cos__tmp = wrapper__cos(self);
  at::_copy_from(wrapper__cos__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__cosh(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cosh(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_cosh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_cosh_out_tmp = wrapper__cosh(self);
  at::_copy_from_and_resize(wrapper_out_cosh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__cosh_(at::Tensor & self) {
  auto wrapper__cosh__tmp = wrapper__cosh(self);
  at::_copy_from(wrapper__cosh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__cumprod(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cumprod(self, dim, dtype);
}

} // anonymous namespace
at::Tensor & wrapper_out_cumprod_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_out_cumprod_out_tmp = wrapper__cumprod(self, dim, dtype);
  at::_copy_from_and_resize(wrapper_out_cumprod_out_tmp, out);
  return out;
}
at::Tensor & wrapper__cumprod_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
  auto wrapper__cumprod__tmp = wrapper__cumprod(self, dim, dtype);
  at::_copy_from(wrapper__cumprod__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__cumsum(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cumsum(self, dim, dtype);
}

} // anonymous namespace
at::Tensor & wrapper_out_cumsum_out(const at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_out_cumsum_out_tmp = wrapper__cumsum(self, dim, dtype);
  at::_copy_from_and_resize(wrapper_out_cumsum_out_tmp, out);
  return out;
}
at::Tensor & wrapper__cumsum_(at::Tensor & self, int64_t dim, c10::optional<at::ScalarType> dtype) {
  auto wrapper__cumsum__tmp = wrapper__cumsum(self, dim, dtype);
  at::_copy_from(wrapper__cumsum__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__diagonal(const at::Tensor & self, int64_t offset, int64_t dim1, int64_t dim2) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::diagonal(self, offset, dim1, dim2);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Tensor_div(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::div(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_div_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_div_out_tmp = wrapper_Tensor_div(self, other);
  at::_copy_from_and_resize(wrapper_out_div_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_div_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_div__tmp = wrapper_Tensor_div(self, other);
  at::_copy_from(wrapper_Tensor_div__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_mode_div(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::div(self, other, rounding_mode);
}

} // anonymous namespace
at::Tensor & wrapper_out_mode_div_out(const at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode, at::Tensor & out) {
  auto wrapper_out_mode_div_out_tmp = wrapper_Tensor_mode_div(self, other, rounding_mode);
  at::_copy_from_and_resize(wrapper_out_mode_div_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_mode_div_(at::Tensor & self, const at::Tensor & other, c10::optional<c10::string_view> rounding_mode) {
  auto wrapper_Tensor_mode_div__tmp = wrapper_Tensor_mode_div(self, other, rounding_mode);
  at::_copy_from(wrapper_Tensor_mode_div__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_div(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::div(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_div_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_div_out_tmp = wrapper_Scalar_div(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_div_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_div_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_div__tmp = wrapper_Scalar_div(self, other);
  at::_copy_from(wrapper_Scalar_div__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__dot(const at::Tensor & self, const at::Tensor & tensor) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::dot(self, tensor);
}

} // anonymous namespace
at::Tensor & wrapper_out_dot_out(const at::Tensor & self, const at::Tensor & tensor, at::Tensor & out) {
  auto wrapper_out_dot_out_tmp = wrapper__dot(self, tensor);
  at::_copy_from_and_resize(wrapper_out_dot_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__embedding(const at::Tensor & weight, const at::Tensor & indices, int64_t padding_idx, bool scale_grad_by_freq, bool sparse) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::embedding(weight, indices, padding_idx, scale_grad_by_freq, sparse);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__embedding_dense_backward(const at::Tensor & grad_output, const at::Tensor & indices, int64_t num_weights, int64_t padding_idx, bool scale_grad_by_freq) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_memory_format_empty(at::IntArrayRef size, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory, c10::optional<at::MemoryFormat> memory_format) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::empty(size, dtype, layout, device, pin_memory, memory_format);
}

} // anonymous namespace
at::Tensor & wrapper_out_empty_out(at::IntArrayRef size, c10::optional<at::MemoryFormat> memory_format, at::Tensor & out) {
  auto wrapper_out_empty_out_tmp = wrapper_memory_format_empty(size, out.scalar_type(), out.layout(), out.device(), c10::nullopt, memory_format);
  at::_copy_from_and_resize(wrapper_out_empty_out_tmp, out);
  return out;
}
namespace {

const at::Tensor & wrapper__resize_(const at::Tensor & self, at::IntArrayRef size, c10::optional<at::MemoryFormat> memory_format) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::resize_(self, size, memory_format);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__empty_strided(at::IntArrayRef size, at::IntArrayRef stride, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::empty_strided(size, stride, dtype, layout, device, pin_memory);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__erf(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::erf(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_erf_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_erf_out_tmp = wrapper__erf(self);
  at::_copy_from_and_resize(wrapper_out_erf_out_tmp, out);
  return out;
}
at::Tensor & wrapper__erf_(at::Tensor & self) {
  auto wrapper__erf__tmp = wrapper__erf(self);
  at::_copy_from(wrapper__erf__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__erfc(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::erfc(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_erfc_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_erfc_out_tmp = wrapper__erfc(self);
  at::_copy_from_and_resize(wrapper_out_erfc_out_tmp, out);
  return out;
}
at::Tensor & wrapper__erfc_(at::Tensor & self) {
  auto wrapper__erfc__tmp = wrapper__erfc(self);
  at::_copy_from(wrapper__erfc__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__exp(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::exp(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_exp_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_exp_out_tmp = wrapper__exp(self);
  at::_copy_from_and_resize(wrapper_out_exp_out_tmp, out);
  return out;
}
at::Tensor & wrapper__exp_(at::Tensor & self) {
  auto wrapper__exp__tmp = wrapper__exp(self);
  at::_copy_from(wrapper__exp__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__expm1(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::expm1(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_expm1_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_expm1_out_tmp = wrapper__expm1(self);
  at::_copy_from_and_resize(wrapper_out_expm1_out_tmp, out);
  return out;
}
at::Tensor & wrapper__expm1_(at::Tensor & self) {
  auto wrapper__expm1__tmp = wrapper__expm1(self);
  at::_copy_from(wrapper__expm1__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_SymInt_expand(const at::Tensor & self, c10::SymIntArrayRef size, bool implicit) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::expand(self, size, implicit);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__expand(const at::Tensor & self, at::IntArrayRef size, bool implicit) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::expand(self, size, implicit);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_out_eye_out(int64_t n, at::Tensor & out) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::eye_out(n, out);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_m_out_eye_out(int64_t n, int64_t m, at::Tensor & out) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::eye_out(n, m, out);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_Scalar_fill_(at::Tensor & self, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::fill_(self, value);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_Tensor_fill_(at::Tensor & self, const at::Tensor & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::fill_(self, value);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__floor(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::floor(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_floor_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_floor_out_tmp = wrapper__floor(self);
  at::_copy_from_and_resize(wrapper_out_floor_out_tmp, out);
  return out;
}
at::Tensor & wrapper__floor_(at::Tensor & self) {
  auto wrapper__floor__tmp = wrapper__floor(self);
  at::_copy_from(wrapper__floor__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__frac(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::frac(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_frac_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_frac_out_tmp = wrapper__frac(self);
  at::_copy_from_and_resize(wrapper_out_frac_out_tmp, out);
  return out;
}
at::Tensor & wrapper__frac_(at::Tensor & self) {
  auto wrapper__frac__tmp = wrapper__frac(self);
  at::_copy_from(wrapper__frac__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_index(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index(self, indices);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_index_out(const at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, at::Tensor & out) {
  auto wrapper_Tensor_out_index_out_tmp = wrapper_Tensor_index(self, indices);
  at::_copy_from_and_resize(wrapper_Tensor_out_index_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__index_copy(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index_copy(self, dim, index, source);
}

} // anonymous namespace
at::Tensor & wrapper_out_index_copy_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, at::Tensor & out) {
  auto wrapper_out_index_copy_out_tmp = wrapper__index_copy(self, dim, index, source);
  at::_copy_from_and_resize(wrapper_out_index_copy_out_tmp, out);
  return out;
}
at::Tensor & wrapper__index_copy_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source) {
  auto wrapper__index_copy__tmp = wrapper__index_copy(self, dim, index, source);
  at::_copy_from(wrapper__index_copy__tmp, self);
  return self;
}
namespace {

at::Tensor & wrapper__index_put_(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index_put_(self, indices, values, accumulate);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper___index_put_impl_(at::Tensor & self, const c10::List<c10::optional<at::Tensor>> & indices, const at::Tensor & values, bool accumulate, bool unsafe) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_index_put_impl_(self, indices, values, accumulate, unsafe);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__inverse(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::inverse(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_inverse_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_inverse_out_tmp = wrapper__inverse(self);
  at::_copy_from_and_resize(wrapper_out_inverse_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__isnan(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::isnan(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__kl_div(const at::Tensor & self, const at::Tensor & target, int64_t reduction, bool log_target) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::kl_div(self, target, reduction, log_target);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__kl_div_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, bool log_target) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::kl_div_backward(grad_output, self, target, reduction, log_target);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__kthvalue(const at::Tensor & self, int64_t k, int64_t dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::kthvalue(self, k, dim, keepdim);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_values_kthvalue_out(const at::Tensor & self, int64_t k, int64_t dim, bool keepdim, at::Tensor & values, at::Tensor & indices) {
  auto wrapper_values_kthvalue_out_tmp = wrapper__kthvalue(self, k, dim, keepdim);
  at::_copy_from_and_resize(std::get<0>(wrapper_values_kthvalue_out_tmp), values);
  at::_copy_from_and_resize(std::get<1>(wrapper_values_kthvalue_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(values, indices);
}
namespace {

at::Tensor wrapper__nan_to_num(const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::nan_to_num(self, nan, posinf, neginf);
}

} // anonymous namespace
at::Tensor & wrapper_out_nan_to_num_out(const at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf, at::Tensor & out) {
  auto wrapper_out_nan_to_num_out_tmp = wrapper__nan_to_num(self, nan, posinf, neginf);
  at::_copy_from_and_resize(wrapper_out_nan_to_num_out_tmp, out);
  return out;
}
at::Tensor & wrapper__nan_to_num_(at::Tensor & self, c10::optional<double> nan, c10::optional<double> posinf, c10::optional<double> neginf) {
  auto wrapper__nan_to_num__tmp = wrapper__nan_to_num(self, nan, posinf, neginf);
  at::_copy_from(wrapper__nan_to_num__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__linspace(const at::Scalar & start, const at::Scalar & end, int64_t steps, c10::optional<at::ScalarType> dtype, c10::optional<at::Layout> layout, c10::optional<at::Device> device, c10::optional<bool> pin_memory) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::linspace(start, end, steps, dtype, layout, device, pin_memory);
}

} // anonymous namespace
at::Tensor & wrapper_out_linspace_out(const at::Scalar & start, const at::Scalar & end, int64_t steps, at::Tensor & out) {
  auto wrapper_out_linspace_out_tmp = wrapper__linspace(start, end, steps, out.scalar_type(), out.layout(), out.device(), c10::nullopt);
  at::_copy_from_and_resize(wrapper_out_linspace_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__log(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::log(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_log_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_log_out_tmp = wrapper__log(self);
  at::_copy_from_and_resize(wrapper_out_log_out_tmp, out);
  return out;
}
at::Tensor & wrapper__log_(at::Tensor & self) {
  auto wrapper__log__tmp = wrapper__log(self);
  at::_copy_from(wrapper__log__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__log10(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::log10(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_log10_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_log10_out_tmp = wrapper__log10(self);
  at::_copy_from_and_resize(wrapper_out_log10_out_tmp, out);
  return out;
}
at::Tensor & wrapper__log10_(at::Tensor & self) {
  auto wrapper__log10__tmp = wrapper__log10(self);
  at::_copy_from(wrapper__log10__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__log1p(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::log1p(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_log1p_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_log1p_out_tmp = wrapper__log1p(self);
  at::_copy_from_and_resize(wrapper_out_log1p_out_tmp, out);
  return out;
}
at::Tensor & wrapper__log1p_(at::Tensor & self) {
  auto wrapper__log1p__tmp = wrapper__log1p(self);
  at::_copy_from(wrapper__log1p__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__log2(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::log2(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_log2_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_log2_out_tmp = wrapper__log2(self);
  at::_copy_from_and_resize(wrapper_out_log2_out_tmp, out);
  return out;
}
at::Tensor & wrapper__log2_(at::Tensor & self) {
  auto wrapper__log2__tmp = wrapper__log2(self);
  at::_copy_from(wrapper__log2__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_xlogy(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::xlogy(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_OutTensor_xlogy_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_OutTensor_xlogy_out_tmp = wrapper_Tensor_xlogy(self, other);
  at::_copy_from_and_resize(wrapper_OutTensor_xlogy_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_xlogy_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_xlogy__tmp = wrapper_Tensor_xlogy(self, other);
  at::_copy_from(wrapper_Tensor_xlogy__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__logdet(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::logdet(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___log_softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_log_softmax(self, dim, half_to_float);
}

} // anonymous namespace
at::Tensor & wrapper_out__log_softmax_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
  auto wrapper_out__log_softmax_out_tmp = wrapper___log_softmax(self, dim, half_to_float);
  at::_copy_from_and_resize(wrapper_out__log_softmax_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper___log_softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_log_softmax_backward_data(grad_output, output, dim, input_dtype);
}

} // anonymous namespace
at::Tensor & wrapper_out__log_softmax_backward_data_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & out) {
  auto wrapper_out__log_softmax_backward_data_out_tmp = wrapper___log_softmax_backward_data(grad_output, output, dim, input_dtype);
  at::_copy_from_and_resize(wrapper_out__log_softmax_backward_data_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__logsumexp(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::logsumexp(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_logsumexp_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_logsumexp_out_tmp = wrapper__logsumexp(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_logsumexp_out_tmp, out);
  return out;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper_dim_max(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max(self, dim, keepdim);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor &,at::Tensor &> wrapper_dim_max_max_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & max, at::Tensor & max_values) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_out(self, dim, keepdim, max, max_values);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__amax(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::amax(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_amax_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_amax_out_tmp = wrapper__amax(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_amax_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__mean(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mean(self, dtype);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_dim_mean(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mean(self, dim, keepdim, dtype);
}

} // anonymous namespace
at::Tensor & wrapper_out_mean_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_out_mean_out_tmp = wrapper_dim_mean(self, dim, keepdim, dtype);
  at::_copy_from_and_resize(wrapper_out_mean_out_tmp, out);
  return out;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper_dim_min(const at::Tensor & self, int64_t dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::min(self, dim, keepdim);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor &,at::Tensor &> wrapper_dim_min_min_out(const at::Tensor & self, int64_t dim, bool keepdim, at::Tensor & min, at::Tensor & min_indices) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::min_out(self, dim, keepdim, min, min_indices);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__amin(const at::Tensor & self, at::IntArrayRef dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::amin(self, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_amin_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_amin_out_tmp = wrapper__amin(self, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_amin_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__mm(const at::Tensor & self, const at::Tensor & mat2) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mm(self, mat2);
}

} // anonymous namespace
at::Tensor & wrapper_out_mm_out(const at::Tensor & self, const at::Tensor & mat2, at::Tensor & out) {
  auto wrapper_out_mm_out_tmp = wrapper__mm(self, mat2);
  at::_copy_from_and_resize(wrapper_out_mm_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_Tensor_mul(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mul(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_mul_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_mul_out_tmp = wrapper_Tensor_mul(self, other);
  at::_copy_from_and_resize(wrapper_out_mul_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_mul_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_mul__tmp = wrapper_Tensor_mul(self, other);
  at::_copy_from(wrapper_Tensor_mul__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_mul(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mul(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_mul_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_mul_out_tmp = wrapper_Scalar_mul(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_mul_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_mul_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_mul__tmp = wrapper_Scalar_mul(self, other);
  at::_copy_from(wrapper_Scalar_mul__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__mv(const at::Tensor & self, const at::Tensor & vec) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mv(self, vec);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_out_mv_out(const at::Tensor & self, const at::Tensor & vec, at::Tensor & out) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mv_out(self, vec, out);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper__native_batch_norm(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_out_native_batch_norm_out(const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & bias, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, bool training, double momentum, double eps, at::Tensor & out, at::Tensor & save_mean, at::Tensor & save_invstd) {
  auto wrapper_out_native_batch_norm_out_tmp = wrapper__native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps);
  at::_copy_from_and_resize(std::get<0>(wrapper_out_native_batch_norm_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_out_native_batch_norm_out_tmp), save_mean);
  at::_copy_from_and_resize(std::get<2>(wrapper_out_native_batch_norm_out_tmp), save_invstd);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(out, save_mean, save_invstd);
}
namespace {

::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper__native_batch_norm_backward(const at::Tensor & grad_out, const at::Tensor & input, const c10::optional<at::Tensor> & weight, const c10::optional<at::Tensor> & running_mean, const c10::optional<at::Tensor> & running_var, const c10::optional<at::Tensor> & save_mean, const c10::optional<at::Tensor> & save_invstd, bool train, double eps, ::std::array<bool,3> output_mask) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::native_batch_norm_backward(grad_out, input, weight, running_mean, running_var, save_mean, save_invstd, train, eps, output_mask);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__permute(const at::Tensor & self, at::IntArrayRef dims) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::permute(self, dims);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__reciprocal(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::reciprocal(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_reciprocal_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_reciprocal_out_tmp = wrapper__reciprocal(self);
  at::_copy_from_and_resize(wrapper_out_reciprocal_out_tmp, out);
  return out;
}
at::Tensor & wrapper__reciprocal_(at::Tensor & self) {
  auto wrapper__reciprocal__tmp = wrapper__reciprocal(self);
  at::_copy_from(wrapper__reciprocal__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__neg(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::neg(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_neg_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_neg_out_tmp = wrapper__neg(self);
  at::_copy_from_and_resize(wrapper_out_neg_out_tmp, out);
  return out;
}
at::Tensor & wrapper__neg_(at::Tensor & self) {
  auto wrapper__neg__tmp = wrapper__neg(self);
  at::_copy_from(wrapper__neg__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__repeat(const at::Tensor & self, at::IntArrayRef repeats) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::repeat(self, repeats);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__round(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::round(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_round_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_round_out_tmp = wrapper__round(self);
  at::_copy_from_and_resize(wrapper_out_round_out_tmp, out);
  return out;
}
at::Tensor & wrapper__round_(at::Tensor & self) {
  auto wrapper__round__tmp = wrapper__round(self);
  at::_copy_from(wrapper__round__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__relu(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::relu(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_relu_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_relu_out_tmp = wrapper__relu(self);
  at::_copy_from_and_resize(wrapper_out_relu_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper__relu_(at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::relu_(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__prelu(const at::Tensor & self, const at::Tensor & weight) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::prelu(self, weight);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__gelu(const at::Tensor & self, c10::string_view approximate) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::gelu(self, approximate);
}

} // anonymous namespace
at::Tensor & wrapper_out_gelu_out(const at::Tensor & self, c10::string_view approximate, at::Tensor & out) {
  auto wrapper_out_gelu_out_tmp = wrapper__gelu(self, approximate);
  at::_copy_from_and_resize(wrapper_out_gelu_out_tmp, out);
  return out;
}
at::Tensor & wrapper__gelu_(at::Tensor & self, c10::string_view approximate) {
  auto wrapper__gelu__tmp = wrapper__gelu(self, approximate);
  at::_copy_from(wrapper__gelu__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__gelu_backward(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::gelu_backward(grad_output, self, approximate);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_gelu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, c10::string_view approximate, at::Tensor & grad_input) {
  auto wrapper_grad_input_gelu_backward_out_tmp = wrapper__gelu_backward(grad_output, self, approximate);
  at::_copy_from_and_resize(wrapper_grad_input_gelu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__hardshrink(const at::Tensor & self, const at::Scalar & lambd) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardshrink(self, lambd);
}

} // anonymous namespace
at::Tensor & wrapper_out_hardshrink_out(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
  auto wrapper_out_hardshrink_out_tmp = wrapper__hardshrink(self, lambd);
  at::_copy_from_and_resize(wrapper_out_hardshrink_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__hardshrink_backward(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardshrink_backward(grad_out, self, lambd);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_hardshrink_backward_out(const at::Tensor & grad_out, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
  auto wrapper_grad_input_hardshrink_backward_out_tmp = wrapper__hardshrink_backward(grad_out, self, lambd);
  at::_copy_from_and_resize(wrapper_grad_input_hardshrink_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__rsqrt(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::rsqrt(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_rsqrt_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_rsqrt_out_tmp = wrapper__rsqrt(self);
  at::_copy_from_and_resize(wrapper_out_rsqrt_out_tmp, out);
  return out;
}
at::Tensor & wrapper__rsqrt_(at::Tensor & self) {
  auto wrapper__rsqrt__tmp = wrapper__rsqrt(self);
  at::_copy_from(wrapper__rsqrt__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_int_select(const at::Tensor & self, int64_t dim, int64_t index) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::select(self, dim, index);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__selu(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::selu(self);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__selu_(at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::selu_(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__celu(const at::Tensor & self, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::celu(self, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_out_celu_out(const at::Tensor & self, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_out_celu_out_tmp = wrapper__celu(self, alpha);
  at::_copy_from_and_resize(wrapper_out_celu_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper__celu_(at::Tensor & self, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::celu_(self, alpha);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__silu(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::silu(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_silu_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_silu_out_tmp = wrapper__silu(self);
  at::_copy_from_and_resize(wrapper_out_silu_out_tmp, out);
  return out;
}
at::Tensor & wrapper__silu_(at::Tensor & self) {
  auto wrapper__silu__tmp = wrapper__silu(self);
  at::_copy_from(wrapper__silu__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__silu_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::silu_backward(grad_output, self);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_silu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
  auto wrapper_grad_input_silu_backward_out_tmp = wrapper__silu_backward(grad_output, self);
  at::_copy_from_and_resize(wrapper_grad_input_silu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__mish(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mish(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_mish_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_mish_out_tmp = wrapper__mish(self);
  at::_copy_from_and_resize(wrapper_out_mish_out_tmp, out);
  return out;
}
at::Tensor & wrapper__mish_(at::Tensor & self) {
  auto wrapper__mish__tmp = wrapper__mish(self);
  at::_copy_from(wrapper__mish__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__sigmoid(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sigmoid(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_sigmoid_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_sigmoid_out_tmp = wrapper__sigmoid(self);
  at::_copy_from_and_resize(wrapper_out_sigmoid_out_tmp, out);
  return out;
}
at::Tensor & wrapper__sigmoid_(at::Tensor & self) {
  auto wrapper__sigmoid__tmp = wrapper__sigmoid(self);
  at::_copy_from(wrapper__sigmoid__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__sin(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sin(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_sin_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_sin_out_tmp = wrapper__sin(self);
  at::_copy_from_and_resize(wrapper_out_sin_out_tmp, out);
  return out;
}
at::Tensor & wrapper__sin_(at::Tensor & self) {
  auto wrapper__sin__tmp = wrapper__sin(self);
  at::_copy_from(wrapper__sin__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__sinh(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sinh(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_sinh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_sinh_out_tmp = wrapper__sinh(self);
  at::_copy_from_and_resize(wrapper_out_sinh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__sinh_(at::Tensor & self) {
  auto wrapper__sinh__tmp = wrapper__sinh(self);
  at::_copy_from(wrapper__sinh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_slice(const at::Tensor & self, int64_t dim, c10::optional<int64_t> start, c10::optional<int64_t> end, int64_t step) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::slice(self, dim, start, end, step);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__slogdet(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::slogdet(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___softmax(const at::Tensor & self, int64_t dim, bool half_to_float) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_softmax(self, dim, half_to_float);
}

} // anonymous namespace
at::Tensor & wrapper_out__softmax_out(const at::Tensor & self, int64_t dim, bool half_to_float, at::Tensor & out) {
  auto wrapper_out__softmax_out_tmp = wrapper___softmax(self, dim, half_to_float);
  at::_copy_from_and_resize(wrapper_out__softmax_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper___softmax_backward_data(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_softmax_backward_data(grad_output, output, dim, input_dtype);
}

} // anonymous namespace
at::Tensor & wrapper_out__softmax_backward_data_out(const at::Tensor & grad_output, const at::Tensor & output, int64_t dim, at::ScalarType input_dtype, at::Tensor & grad_input) {
  auto wrapper_out__softmax_backward_data_out_tmp = wrapper___softmax_backward_data(grad_output, output, dim, input_dtype);
  at::_copy_from_and_resize(wrapper_out__softmax_backward_data_out_tmp, grad_input);
  return grad_input;
}
namespace {

::std::vector<at::Tensor> wrapper_Tensor_split(const at::Tensor & self, int64_t split_size, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::split(self, split_size, dim);
}

} // anonymous namespace
namespace {

::std::vector<at::Tensor> wrapper__split_with_sizes(const at::Tensor & self, at::IntArrayRef split_sizes, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::split_with_sizes(self, split_sizes, dim);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__squeeze(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::squeeze(self);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__squeeze_(at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::squeeze_(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_dim_squeeze(const at::Tensor & self, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::squeeze(self, dim);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_dim_squeeze_(at::Tensor & self, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::squeeze_(self, dim);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__stack(at::TensorList tensors, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::stack(tensors, dim);
}

} // anonymous namespace
at::Tensor & wrapper_out_stack_out(at::TensorList tensors, int64_t dim, at::Tensor & out) {
  auto wrapper_out_stack_out_tmp = wrapper__stack(tensors, dim);
  at::_copy_from_and_resize(wrapper_out_stack_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__sum(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sum(self, dtype);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_dim_IntList_sum(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sum(self, dim, keepdim, dtype);
}

} // anonymous namespace
at::Tensor & wrapper_IntList_out_sum_out(const at::Tensor & self, at::IntArrayRef dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_IntList_out_sum_out_tmp = wrapper_dim_IntList_sum(self, dim, keepdim, dtype);
  at::_copy_from_and_resize(wrapper_IntList_out_sum_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__sqrt(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sqrt(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_sqrt_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_sqrt_out_tmp = wrapper__sqrt(self);
  at::_copy_from_and_resize(wrapper_out_sqrt_out_tmp, out);
  return out;
}
at::Tensor & wrapper__sqrt_(at::Tensor & self) {
  auto wrapper__sqrt__tmp = wrapper__sqrt(self);
  at::_copy_from(wrapper__sqrt__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__std(const at::Tensor & self, bool unbiased) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::std(self, unbiased);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_dim_std(const at::Tensor & self, at::IntArrayRef dim, bool unbiased, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::std(self, dim, unbiased, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_std_out(const at::Tensor & self, at::IntArrayRef dim, bool unbiased, bool keepdim, at::Tensor & out) {
  auto wrapper_out_std_out_tmp = wrapper_dim_std(self, dim, unbiased, keepdim);
  at::_copy_from_and_resize(wrapper_out_std_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_correction_std(const at::Tensor & self, at::OptionalIntArrayRef dim, c10::optional<int64_t> correction, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::std(self, dim, correction, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_correction_out_std_out(const at::Tensor & self, at::OptionalIntArrayRef dim, c10::optional<int64_t> correction, bool keepdim, at::Tensor & out) {
  auto wrapper_correction_out_std_out_tmp = wrapper_correction_std(self, dim, correction, keepdim);
  at::_copy_from_and_resize(wrapper_correction_out_std_out_tmp, out);
  return out;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper_correction_std_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, c10::optional<int64_t> correction, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::std_mean(self, dim, correction, keepdim);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__prod(const at::Tensor & self, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::prod(self, dtype);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_dim_int_prod(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::prod(self, dim, keepdim, dtype);
}

} // anonymous namespace
at::Tensor & wrapper_int_out_prod_out(const at::Tensor & self, int64_t dim, bool keepdim, c10::optional<at::ScalarType> dtype, at::Tensor & out) {
  auto wrapper_int_out_prod_out_tmp = wrapper_dim_int_prod(self, dim, keepdim, dtype);
  at::_copy_from_and_resize(wrapper_int_out_prod_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__t(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::t(self);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__t_(at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::t_(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__tan(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::tan(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_tan_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_tan_out_tmp = wrapper__tan(self);
  at::_copy_from_and_resize(wrapper_out_tan_out_tmp, out);
  return out;
}
at::Tensor & wrapper__tan_(at::Tensor & self) {
  auto wrapper__tan__tmp = wrapper__tan(self);
  at::_copy_from(wrapper__tan__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__tanh(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::tanh(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_tanh_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_tanh_out_tmp = wrapper__tanh(self);
  at::_copy_from_and_resize(wrapper_out_tanh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__tanh_(at::Tensor & self) {
  auto wrapper__tanh__tmp = wrapper__tanh(self);
  at::_copy_from(wrapper__tanh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__threshold(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::threshold(self, threshold, value);
}

} // anonymous namespace
at::Tensor & wrapper_out_threshold_out(const at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_out_threshold_out_tmp = wrapper__threshold(self, threshold, value);
  at::_copy_from_and_resize(wrapper_out_threshold_out_tmp, out);
  return out;
}
at::Tensor & wrapper__threshold_(at::Tensor & self, const at::Scalar & threshold, const at::Scalar & value) {
  auto wrapper__threshold__tmp = wrapper__threshold(self, threshold, value);
  at::_copy_from(wrapper__threshold__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__threshold_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::threshold_backward(grad_output, self, threshold);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_threshold_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & threshold, at::Tensor & grad_input) {
  auto wrapper_grad_input_threshold_backward_out_tmp = wrapper__threshold_backward(grad_output, self, threshold);
  at::_copy_from_and_resize(wrapper_grad_input_threshold_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper_int_transpose(const at::Tensor & self, int64_t dim0, int64_t dim1) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::transpose(self, dim0, dim1);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__transpose_(at::Tensor & self, int64_t dim0, int64_t dim1) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::transpose_(self, dim0, dim1);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__flip(const at::Tensor & self, at::IntArrayRef dims) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::flip(self, dims);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__roll(const at::Tensor & self, at::IntArrayRef shifts, at::IntArrayRef dims) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::roll(self, shifts, dims);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___trilinear(const at::Tensor & i1, const at::Tensor & i2, const at::Tensor & i3, at::IntArrayRef expand1, at::IntArrayRef expand2, at::IntArrayRef expand3, at::IntArrayRef sumdim, int64_t unroll_dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_trilinear(i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__trunc(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::trunc(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_trunc_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_trunc_out_tmp = wrapper__trunc(self);
  at::_copy_from_and_resize(wrapper_out_trunc_out_tmp, out);
  return out;
}
at::Tensor & wrapper__trunc_(at::Tensor & self) {
  auto wrapper__trunc__tmp = wrapper__trunc(self);
  at::_copy_from(wrapper__trunc__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper___unsafe_view(const at::Tensor & self, at::IntArrayRef size) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_unsafe_view(self, size);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__unsqueeze(const at::Tensor & self, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::unsqueeze(self, dim);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__unsqueeze_(at::Tensor & self, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::unsqueeze_(self, dim);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_correction_var(const at::Tensor & self, at::OptionalIntArrayRef dim, c10::optional<int64_t> correction, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::var(self, dim, correction, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_correction_out_var_out(const at::Tensor & self, at::OptionalIntArrayRef dim, c10::optional<int64_t> correction, bool keepdim, at::Tensor & out) {
  auto wrapper_correction_out_var_out_tmp = wrapper_correction_var(self, dim, correction, keepdim);
  at::_copy_from_and_resize(wrapper_correction_out_var_out_tmp, out);
  return out;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper_correction_var_mean(const at::Tensor & self, at::OptionalIntArrayRef dim, c10::optional<int64_t> correction, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::var_mean(self, dim, correction, keepdim);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_self_where(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::where(condition, self, other);
}

} // anonymous namespace
at::Tensor & wrapper_self_out_where_out(const at::Tensor & condition, const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_self_out_where_out_tmp = wrapper_self_where(condition, self, other);
  at::_copy_from_and_resize(wrapper_self_out_where_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_ScalarOpt_dtype_norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::ScalarType dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::norm(self, p, dtype);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Scalar_norm(const at::Tensor & self, const at::Scalar & p) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::norm(self, p);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_ScalarOpt_dim_dtype_norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::norm(self, p, dim, keepdim, dtype);
}

} // anonymous namespace
at::Tensor & wrapper_dtype_out_norm_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::ScalarType dtype, at::Tensor & out) {
  auto wrapper_dtype_out_norm_out_tmp = wrapper_ScalarOpt_dim_dtype_norm(self, p, dim, keepdim, dtype);
  at::_copy_from_and_resize(wrapper_dtype_out_norm_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_ScalarOpt_dim_norm(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::norm(self, p, dim, keepdim);
}

} // anonymous namespace
at::Tensor & wrapper_out_norm_out(const at::Tensor & self, const c10::optional<at::Scalar> & p, at::IntArrayRef dim, bool keepdim, at::Tensor & out) {
  auto wrapper_out_norm_out_tmp = wrapper_ScalarOpt_dim_norm(self, p, dim, keepdim);
  at::_copy_from_and_resize(wrapper_out_norm_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__clone(const at::Tensor & self, c10::optional<at::MemoryFormat> memory_format) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::clone(self, memory_format);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__zero_(at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::zero_(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Tensor_sub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sub(self, other, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_out_sub_out(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_out_sub_out_tmp = wrapper_Tensor_sub(self, other, alpha);
  at::_copy_from_and_resize(wrapper_out_sub_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_sub_(at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
  auto wrapper_Tensor_sub__tmp = wrapper_Tensor_sub(self, other, alpha);
  at::_copy_from(wrapper_Tensor_sub__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_sub(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sub(self, other, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_sub_out(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_Scalar_out_sub_out_tmp = wrapper_Scalar_sub(self, other, alpha);
  at::_copy_from_and_resize(wrapper_Scalar_out_sub_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_sub_(at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
  auto wrapper_Scalar_sub__tmp = wrapper_Scalar_sub(self, other, alpha);
  at::_copy_from(wrapper_Scalar_sub__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_rsub(const at::Tensor & self, const at::Tensor & other, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::rsub(self, other, alpha);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Scalar_rsub(const at::Tensor & self, const at::Scalar & other, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::rsub(self, other, alpha);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__addmm(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::addmm(self, mat1, mat2, beta, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_out_addmm_out(const at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_out_addmm_out_tmp = wrapper__addmm(self, mat1, mat2, beta, alpha);
  at::_copy_from_and_resize(wrapper_out_addmm_out_tmp, out);
  return out;
}
at::Tensor & wrapper__addmm_(at::Tensor & self, const at::Tensor & mat1, const at::Tensor & mat2, const at::Scalar & beta, const at::Scalar & alpha) {
  auto wrapper__addmm__tmp = wrapper__addmm(self, mat1, mat2, beta, alpha);
  at::_copy_from(wrapper__addmm__tmp, self);
  return self;
}
namespace {

::std::vector<at::Tensor> wrapper___to_cpu(at::TensorList tensors) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_to_cpu(tensors);
}

} // anonymous namespace
namespace {

::std::vector<at::Tensor> wrapper_int_unbind(const at::Tensor & self, int64_t dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::unbind(self, dim);
}

} // anonymous namespace
namespace {

at::Scalar wrapper___local_scalar_dense(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_local_scalar_dense(self);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper___pack_padded_sequence(const at::Tensor & input, const at::Tensor & lengths, bool batch_first) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_pack_padded_sequence(input, lengths, batch_first);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_Scalar_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::masked_fill_(self, mask, value);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_Tensor_masked_fill_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::masked_fill_(self, mask, value);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__masked_scatter_(at::Tensor & self, const at::Tensor & mask, const at::Tensor & source) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::masked_scatter_(self, mask, source);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__view(const at::Tensor & self, at::IntArrayRef size) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::view(self, size);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__put_(at::Tensor & self, const at::Tensor & index, const at::Tensor & source, bool accumulate) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::put_(self, index, source, accumulate);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__index_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index_add(self, dim, index, source, alpha);
}

} // anonymous namespace
at::Tensor & wrapper_out_index_add_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha, at::Tensor & out) {
  auto wrapper_out_index_add_out_tmp = wrapper__index_add(self, dim, index, source, alpha);
  at::_copy_from_and_resize(wrapper_out_index_add_out_tmp, out);
  return out;
}
at::Tensor & wrapper__index_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & source, const at::Scalar & alpha) {
  auto wrapper__index_add__tmp = wrapper__index_add(self, dim, index, source, alpha);
  at::_copy_from(wrapper__index_add__tmp, self);
  return self;
}
namespace {

at::Tensor & wrapper_int_Scalar_index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index_fill_(self, dim, index, value);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_int_Tensor_index_fill_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index_fill_(self, dim, index, value);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_src_scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::scatter(self, dim, index, src);
}

} // anonymous namespace
at::Tensor & wrapper_src_out_scatter_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
  auto wrapper_src_out_scatter_out_tmp = wrapper_src_scatter(self, dim, index, src);
  at::_copy_from_and_resize(wrapper_src_out_scatter_out_tmp, out);
  return out;
}
at::Tensor & wrapper_src_scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
  auto wrapper_src_scatter__tmp = wrapper_src_scatter(self, dim, index, src);
  at::_copy_from(wrapper_src_scatter__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_value_scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::scatter(self, dim, index, value);
}

} // anonymous namespace
at::Tensor & wrapper_value_out_scatter_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_value_out_scatter_out_tmp = wrapper_value_scatter(self, dim, index, value);
  at::_copy_from_and_resize(wrapper_value_out_scatter_out_tmp, out);
  return out;
}
at::Tensor & wrapper_value_scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value) {
  auto wrapper_value_scatter__tmp = wrapper_value_scatter(self, dim, index, value);
  at::_copy_from(wrapper_value_scatter__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_reduce_scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::scatter(self, dim, index, src, reduce);
}

} // anonymous namespace
at::Tensor & wrapper_reduce_out_scatter_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce, at::Tensor & out) {
  auto wrapper_reduce_out_scatter_out_tmp = wrapper_reduce_scatter(self, dim, index, src, reduce);
  at::_copy_from_and_resize(wrapper_reduce_out_scatter_out_tmp, out);
  return out;
}
at::Tensor & wrapper_reduce_scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, c10::string_view reduce) {
  auto wrapper_reduce_scatter__tmp = wrapper_reduce_scatter(self, dim, index, src, reduce);
  at::_copy_from(wrapper_reduce_scatter__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_value_reduce_scatter(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::scatter(self, dim, index, value, reduce);
}

} // anonymous namespace
at::Tensor & wrapper_value_reduce_out_scatter_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce, at::Tensor & out) {
  auto wrapper_value_reduce_out_scatter_out_tmp = wrapper_value_reduce_scatter(self, dim, index, value, reduce);
  at::_copy_from_and_resize(wrapper_value_reduce_out_scatter_out_tmp, out);
  return out;
}
at::Tensor & wrapper_value_reduce_scatter_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Scalar & value, c10::string_view reduce) {
  auto wrapper_value_reduce_scatter__tmp = wrapper_value_reduce_scatter(self, dim, index, value, reduce);
  at::_copy_from(wrapper_value_reduce_scatter__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__scatter_add(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::scatter_add(self, dim, index, src);
}

} // anonymous namespace
at::Tensor & wrapper_out_scatter_add_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src, at::Tensor & out) {
  auto wrapper_out_scatter_add_out_tmp = wrapper__scatter_add(self, dim, index, src);
  at::_copy_from_and_resize(wrapper_out_scatter_add_out_tmp, out);
  return out;
}
at::Tensor & wrapper__scatter_add_(at::Tensor & self, int64_t dim, const at::Tensor & index, const at::Tensor & src) {
  auto wrapper__scatter_add__tmp = wrapper__scatter_add(self, dim, index, src);
  at::_copy_from(wrapper__scatter_add__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_eq(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::eq(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_eq_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_eq_out_tmp = wrapper_Scalar_eq(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_eq_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_eq_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_eq__tmp = wrapper_Scalar_eq(self, other);
  at::_copy_from(wrapper_Scalar_eq__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_eq(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::eq(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_eq_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_eq_out_tmp = wrapper_Tensor_eq(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_eq_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_eq_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_eq__tmp = wrapper_Tensor_eq(self, other);
  at::_copy_from(wrapper_Tensor_eq__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_bitwise_and(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_and(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_bitwise_and_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_bitwise_and_out_tmp = wrapper_Tensor_bitwise_and(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_bitwise_and_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_bitwise_and_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_bitwise_and__tmp = wrapper_Tensor_bitwise_and(self, other);
  at::_copy_from(wrapper_Tensor_bitwise_and__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_bitwise_and(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_and(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_bitwise_and_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_bitwise_and_out_tmp = wrapper_Scalar_bitwise_and(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_bitwise_and_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_bitwise_and_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_bitwise_and__tmp = wrapper_Scalar_bitwise_and(self, other);
  at::_copy_from(wrapper_Scalar_bitwise_and__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_bitwise_or(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_or(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_bitwise_or_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_bitwise_or_out_tmp = wrapper_Tensor_bitwise_or(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_bitwise_or_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_bitwise_or_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_bitwise_or__tmp = wrapper_Tensor_bitwise_or(self, other);
  at::_copy_from(wrapper_Tensor_bitwise_or__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_bitwise_or(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_or(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_bitwise_or_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_bitwise_or_out_tmp = wrapper_Scalar_bitwise_or(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_bitwise_or_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_bitwise_or_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_bitwise_or__tmp = wrapper_Scalar_bitwise_or(self, other);
  at::_copy_from(wrapper_Scalar_bitwise_or__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_bitwise_xor(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_xor(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_bitwise_xor_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_bitwise_xor_out_tmp = wrapper_Tensor_bitwise_xor(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_bitwise_xor_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_bitwise_xor_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_bitwise_xor__tmp = wrapper_Tensor_bitwise_xor(self, other);
  at::_copy_from(wrapper_Tensor_bitwise_xor__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_bitwise_xor(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::bitwise_xor(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_bitwise_xor_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_bitwise_xor_out_tmp = wrapper_Scalar_bitwise_xor(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_bitwise_xor_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_bitwise_xor_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_bitwise_xor__tmp = wrapper_Scalar_bitwise_xor(self, other);
  at::_copy_from(wrapper_Scalar_bitwise_xor__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar___lshift__(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__lshift__(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out___lshift___out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out___lshift___out_tmp = wrapper_Scalar___lshift__(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out___lshift___out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper_Scalar___ilshift__(at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__ilshift__(self, other);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Tensor___lshift__(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__lshift__(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out___lshift___out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out___lshift___out_tmp = wrapper_Tensor___lshift__(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out___lshift___out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper_Tensor___ilshift__(at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__ilshift__(self, other);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Scalar___rshift__(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__rshift__(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out___rshift___out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out___rshift___out_tmp = wrapper_Scalar___rshift__(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out___rshift___out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper_Scalar___irshift__(at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__irshift__(self, other);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Tensor___rshift__(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__rshift__(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out___rshift___out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out___rshift___out_tmp = wrapper_Tensor___rshift__(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out___rshift___out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper_Tensor___irshift__(at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::__irshift__(self, other);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__tril(const at::Tensor & self, int64_t diagonal) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::tril(self, diagonal);
}

} // anonymous namespace
at::Tensor & wrapper_out_tril_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
  auto wrapper_out_tril_out_tmp = wrapper__tril(self, diagonal);
  at::_copy_from_and_resize(wrapper_out_tril_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper__tril_(at::Tensor & self, int64_t diagonal) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::tril_(self, diagonal);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__triu(const at::Tensor & self, int64_t diagonal) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::triu(self, diagonal);
}

} // anonymous namespace
at::Tensor & wrapper_out_triu_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
  auto wrapper_out_triu_out_tmp = wrapper__triu(self, diagonal);
  at::_copy_from_and_resize(wrapper_out_triu_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper__triu_(at::Tensor & self, int64_t diagonal) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::triu_(self, diagonal);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Scalar_lerp(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::lerp(self, end, weight);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_lerp_out(const at::Tensor & self, const at::Tensor & end, const at::Scalar & weight, at::Tensor & out) {
  auto wrapper_Scalar_out_lerp_out_tmp = wrapper_Scalar_lerp(self, end, weight);
  at::_copy_from_and_resize(wrapper_Scalar_out_lerp_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_lerp_(at::Tensor & self, const at::Tensor & end, const at::Scalar & weight) {
  auto wrapper_Scalar_lerp__tmp = wrapper_Scalar_lerp(self, end, weight);
  at::_copy_from(wrapper_Scalar_lerp__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_lerp(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::lerp(self, end, weight);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_lerp_out(const at::Tensor & self, const at::Tensor & end, const at::Tensor & weight, at::Tensor & out) {
  auto wrapper_Tensor_out_lerp_out_tmp = wrapper_Tensor_lerp(self, end, weight);
  at::_copy_from_and_resize(wrapper_Tensor_out_lerp_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_lerp_(at::Tensor & self, const at::Tensor & end, const at::Tensor & weight) {
  auto wrapper_Tensor_lerp__tmp = wrapper_Tensor_lerp(self, end, weight);
  at::_copy_from(wrapper_Tensor_lerp__tmp, self);
  return self;
}
namespace {

at::Tensor & wrapper_from_random_(at::Tensor & self, int64_t from, c10::optional<int64_t> to, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::random_(self, from, to, generator);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper_to_random_(at::Tensor & self, int64_t to, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::random_(self, to, generator);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__random_(at::Tensor & self, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::random_(self, generator);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__uniform_(at::Tensor & self, double from, double to, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::uniform_(self, from, to, generator);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper__exponential_(at::Tensor & self, double lambd, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::exponential_(self, lambd, generator);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__diag(const at::Tensor & self, int64_t diagonal) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::diag(self, diagonal);
}

} // anonymous namespace
at::Tensor & wrapper_out_diag_out(const at::Tensor & self, int64_t diagonal, at::Tensor & out) {
  auto wrapper_out_diag_out_tmp = wrapper__diag(self, diagonal);
  at::_copy_from_and_resize(wrapper_out_diag_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__cross(const at::Tensor & self, const at::Tensor & other, c10::optional<int64_t> dim) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cross(self, other, dim);
}

} // anonymous namespace
at::Tensor & wrapper_out_cross_out(const at::Tensor & self, const at::Tensor & other, c10::optional<int64_t> dim, at::Tensor & out) {
  auto wrapper_out_cross_out_tmp = wrapper__cross(self, other, dim);
  at::_copy_from_and_resize(wrapper_out_cross_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__trace(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::trace(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Scalar_ne(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::ne(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_ne_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_ne_out_tmp = wrapper_Scalar_ne(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_ne_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_ne_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_ne__tmp = wrapper_Scalar_ne(self, other);
  at::_copy_from(wrapper_Scalar_ne__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_ne(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::ne(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_ne_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_ne_out_tmp = wrapper_Tensor_ne(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_ne_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_ne_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_ne__tmp = wrapper_Tensor_ne(self, other);
  at::_copy_from(wrapper_Tensor_ne__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_ge(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::ge(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_ge_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_ge_out_tmp = wrapper_Scalar_ge(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_ge_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_ge_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_ge__tmp = wrapper_Scalar_ge(self, other);
  at::_copy_from(wrapper_Scalar_ge__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_ge(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::ge(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_ge_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_ge_out_tmp = wrapper_Tensor_ge(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_ge_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_ge_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_ge__tmp = wrapper_Tensor_ge(self, other);
  at::_copy_from(wrapper_Tensor_ge__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_le(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::le(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_le_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_le_out_tmp = wrapper_Scalar_le(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_le_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_le_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_le__tmp = wrapper_Scalar_le(self, other);
  at::_copy_from(wrapper_Scalar_le__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_le(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::le(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_le_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_le_out_tmp = wrapper_Tensor_le(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_le_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_le_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_le__tmp = wrapper_Tensor_le(self, other);
  at::_copy_from(wrapper_Tensor_le__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_gt(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::gt(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_gt_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_gt_out_tmp = wrapper_Scalar_gt(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_gt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_gt_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_gt__tmp = wrapper_Scalar_gt(self, other);
  at::_copy_from(wrapper_Scalar_gt__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_gt(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::gt(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_gt_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_gt_out_tmp = wrapper_Tensor_gt(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_gt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_gt_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_gt__tmp = wrapper_Tensor_gt(self, other);
  at::_copy_from(wrapper_Tensor_gt__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_lt(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::lt(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_lt_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_lt_out_tmp = wrapper_Scalar_lt(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_lt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_lt_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_lt__tmp = wrapper_Scalar_lt(self, other);
  at::_copy_from(wrapper_Scalar_lt__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_lt(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::lt(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_lt_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_lt_out_tmp = wrapper_Tensor_lt(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_lt_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_lt_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_lt__tmp = wrapper_Tensor_lt(self, other);
  at::_copy_from(wrapper_Tensor_lt__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__take(const at::Tensor & self, const at::Tensor & index) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::take(self, index);
}

} // anonymous namespace
at::Tensor & wrapper_out_take_out(const at::Tensor & self, const at::Tensor & index, at::Tensor & out) {
  auto wrapper_out_take_out_tmp = wrapper__take(self, index);
  at::_copy_from_and_resize(wrapper_out_take_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__index_select(const at::Tensor & self, int64_t dim, const at::Tensor & index) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::index_select(self, dim, index);
}

} // anonymous namespace
at::Tensor & wrapper_out_index_select_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, at::Tensor & out) {
  auto wrapper_out_index_select_out_tmp = wrapper__index_select(self, dim, index);
  at::_copy_from_and_resize(wrapper_out_index_select_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__masked_select(const at::Tensor & self, const at::Tensor & mask) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::masked_select(self, mask);
}

} // anonymous namespace
at::Tensor & wrapper_out_masked_select_out(const at::Tensor & self, const at::Tensor & mask, at::Tensor & out) {
  auto wrapper_out_masked_select_out_tmp = wrapper__masked_select(self, mask);
  at::_copy_from_and_resize(wrapper_out_masked_select_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__nonzero(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::nonzero(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_nonzero_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_nonzero_out_tmp = wrapper__nonzero(self);
  at::_copy_from_and_resize(wrapper_out_nonzero_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__gather(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::gather(self, dim, index, sparse_grad);
}

} // anonymous namespace
at::Tensor & wrapper_out_gather_out(const at::Tensor & self, int64_t dim, const at::Tensor & index, bool sparse_grad, at::Tensor & out) {
  auto wrapper_out_gather_out_tmp = wrapper__gather(self, dim, index, sparse_grad);
  at::_copy_from_and_resize(wrapper_out_gather_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__addcmul(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::addcmul(self, tensor1, tensor2, value);
}

} // anonymous namespace
at::Tensor & wrapper_out_addcmul_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_out_addcmul_out_tmp = wrapper__addcmul(self, tensor1, tensor2, value);
  at::_copy_from_and_resize(wrapper_out_addcmul_out_tmp, out);
  return out;
}
at::Tensor & wrapper__addcmul_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
  auto wrapper__addcmul__tmp = wrapper__addcmul(self, tensor1, tensor2, value);
  at::_copy_from(wrapper__addcmul__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__addcdiv(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::addcdiv(self, tensor1, tensor2, value);
}

} // anonymous namespace
at::Tensor & wrapper_out_addcdiv_out(const at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value, at::Tensor & out) {
  auto wrapper_out_addcdiv_out_tmp = wrapper__addcdiv(self, tensor1, tensor2, value);
  at::_copy_from_and_resize(wrapper_out_addcdiv_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper__addcdiv_(at::Tensor & self, const at::Tensor & tensor1, const at::Tensor & tensor2, const at::Scalar & value) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::addcdiv_(self, tensor1, tensor2, value);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__triangular_solve(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::triangular_solve(self, A, upper, transpose, unitriangular);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_X_triangular_solve_out(const at::Tensor & self, const at::Tensor & A, bool upper, bool transpose, bool unitriangular, at::Tensor & X, at::Tensor & M) {
  auto wrapper_X_triangular_solve_out_tmp = wrapper__triangular_solve(self, A, upper, transpose, unitriangular);
  at::_copy_from_and_resize(std::get<0>(wrapper_X_triangular_solve_out_tmp), X);
  at::_copy_from_and_resize(std::get<1>(wrapper_X_triangular_solve_out_tmp), M);
  return ::std::tuple<at::Tensor &,at::Tensor &>(X, M);
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__symeig(const at::Tensor & self, bool eigenvectors, bool upper) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::symeig(self, eigenvectors, upper);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_e_symeig_out(const at::Tensor & self, bool eigenvectors, bool upper, at::Tensor & e, at::Tensor & V) {
  auto wrapper_e_symeig_out_tmp = wrapper__symeig(self, eigenvectors, upper);
  at::_copy_from_and_resize(std::get<0>(wrapper_e_symeig_out_tmp), e);
  at::_copy_from_and_resize(std::get<1>(wrapper_e_symeig_out_tmp), V);
  return ::std::tuple<at::Tensor &,at::Tensor &>(e, V);
}
namespace {

::std::tuple<at::Tensor,at::Tensor,at::Tensor> wrapper__svd(const at::Tensor & self, bool some, bool compute_uv) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::svd(self, some, compute_uv);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &> wrapper_U_svd_out(const at::Tensor & self, bool some, bool compute_uv, at::Tensor & U, at::Tensor & S, at::Tensor & V) {
  auto wrapper_U_svd_out_tmp = wrapper__svd(self, some, compute_uv);
  at::_copy_from_and_resize(std::get<0>(wrapper_U_svd_out_tmp), U);
  at::_copy_from_and_resize(std::get<1>(wrapper_U_svd_out_tmp), S);
  at::_copy_from_and_resize(std::get<2>(wrapper_U_svd_out_tmp), V);
  return ::std::tuple<at::Tensor &,at::Tensor &,at::Tensor &>(U, S, V);
}
namespace {

at::Tensor wrapper__cholesky(const at::Tensor & self, bool upper) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::cholesky(self, upper);
}

} // anonymous namespace
at::Tensor & wrapper_out_cholesky_out(const at::Tensor & self, bool upper, at::Tensor & out) {
  auto wrapper_out_cholesky_out_tmp = wrapper__cholesky(self, upper);
  at::_copy_from_and_resize(wrapper_out_cholesky_out_tmp, out);
  return out;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__qr(const at::Tensor & self, bool some) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::qr(self, some);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_Q_qr_out(const at::Tensor & self, bool some, at::Tensor & Q, at::Tensor & R) {
  auto wrapper_Q_qr_out_tmp = wrapper__qr(self, some);
  at::_copy_from_and_resize(std::get<0>(wrapper_Q_qr_out_tmp), Q);
  at::_copy_from_and_resize(std::get<1>(wrapper_Q_qr_out_tmp), R);
  return ::std::tuple<at::Tensor &,at::Tensor &>(Q, R);
}
namespace {

at::Tensor wrapper__erfinv(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::erfinv(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_erfinv_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_erfinv_out_tmp = wrapper__erfinv(self);
  at::_copy_from_and_resize(wrapper_out_erfinv_out_tmp, out);
  return out;
}
at::Tensor & wrapper__erfinv_(at::Tensor & self) {
  auto wrapper__erfinv__tmp = wrapper__erfinv(self);
  at::_copy_from(wrapper__erfinv__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__sign(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sign(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_sign_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_sign_out_tmp = wrapper__sign(self);
  at::_copy_from_and_resize(wrapper_out_sign_out_tmp, out);
  return out;
}
at::Tensor & wrapper__sign_(at::Tensor & self) {
  auto wrapper__sign__tmp = wrapper__sign(self);
  at::_copy_from(wrapper__sign__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__atan2(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::atan2(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_atan2_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_atan2_out_tmp = wrapper__atan2(self, other);
  at::_copy_from_and_resize(wrapper_out_atan2_out_tmp, out);
  return out;
}
at::Tensor & wrapper__atan2_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper__atan2__tmp = wrapper__atan2(self, other);
  at::_copy_from(wrapper__atan2__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_fmod(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::fmod(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_fmod_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_fmod_out_tmp = wrapper_Scalar_fmod(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_fmod_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_fmod_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_fmod__tmp = wrapper_Scalar_fmod(self, other);
  at::_copy_from(wrapper_Scalar_fmod__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_fmod(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::fmod(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_fmod_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_fmod_out_tmp = wrapper_Tensor_fmod(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_fmod_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_fmod_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_fmod__tmp = wrapper_Tensor_fmod(self, other);
  at::_copy_from(wrapper_Tensor_fmod__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_remainder(const at::Tensor & self, const at::Scalar & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::remainder(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_remainder_out(const at::Tensor & self, const at::Scalar & other, at::Tensor & out) {
  auto wrapper_Scalar_out_remainder_out_tmp = wrapper_Scalar_remainder(self, other);
  at::_copy_from_and_resize(wrapper_Scalar_out_remainder_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_remainder_(at::Tensor & self, const at::Scalar & other) {
  auto wrapper_Scalar_remainder__tmp = wrapper_Scalar_remainder(self, other);
  at::_copy_from(wrapper_Scalar_remainder__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Tensor_remainder(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::remainder(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_out_remainder_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_Tensor_out_remainder_out_tmp = wrapper_Tensor_remainder(self, other);
  at::_copy_from_and_resize(wrapper_Tensor_out_remainder_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_remainder_(at::Tensor & self, const at::Tensor & other) {
  auto wrapper_Tensor_remainder__tmp = wrapper_Tensor_remainder(self, other);
  at::_copy_from(wrapper_Tensor_remainder__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__min(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::min(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__max(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max(self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__maximum(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::maximum(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_maximum_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_maximum_out_tmp = wrapper__maximum(self, other);
  at::_copy_from_and_resize(wrapper_out_maximum_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__minimum(const at::Tensor & self, const at::Tensor & other) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::minimum(self, other);
}

} // anonymous namespace
at::Tensor & wrapper_out_minimum_out(const at::Tensor & self, const at::Tensor & other, at::Tensor & out) {
  auto wrapper_out_minimum_out_tmp = wrapper__minimum(self, other);
  at::_copy_from_and_resize(wrapper_out_minimum_out_tmp, out);
  return out;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__sort(const at::Tensor & self, int64_t dim, bool descending) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sort(self, dim, descending);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_values_sort_out(const at::Tensor & self, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
  auto wrapper_values_sort_out_tmp = wrapper__sort(self, dim, descending);
  at::_copy_from_and_resize(std::get<0>(wrapper_values_sort_out_tmp), values);
  at::_copy_from_and_resize(std::get<1>(wrapper_values_sort_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(values, indices);
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper_stable_sort(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sort(self, stable, dim, descending);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_values_stable_sort_out(const at::Tensor & self, c10::optional<bool> stable, int64_t dim, bool descending, at::Tensor & values, at::Tensor & indices) {
  auto wrapper_values_stable_sort_out_tmp = wrapper_stable_sort(self, stable, dim, descending);
  at::_copy_from_and_resize(std::get<0>(wrapper_values_stable_sort_out_tmp), values);
  at::_copy_from_and_resize(std::get<1>(wrapper_values_stable_sort_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(values, indices);
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__topk(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::topk(self, k, dim, largest, sorted);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_values_topk_out(const at::Tensor & self, int64_t k, int64_t dim, bool largest, bool sorted, at::Tensor & values, at::Tensor & indices) {
  auto wrapper_values_topk_out_tmp = wrapper__topk(self, k, dim, largest, sorted);
  at::_copy_from_and_resize(std::get<0>(wrapper_values_topk_out_tmp), values);
  at::_copy_from_and_resize(std::get<1>(wrapper_values_topk_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(values, indices);
}
namespace {

at::Tensor wrapper__all(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::all(self);
}

} // anonymous namespace
at::Tensor & wrapper_all_out_all_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_all_out_all_out_tmp = wrapper__all(self);
  at::_copy_from_and_resize(wrapper_all_out_all_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__any(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::any(self);
}

} // anonymous namespace
at::Tensor & wrapper_all_out_any_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_all_out_any_out_tmp = wrapper__any(self);
  at::_copy_from_and_resize(wrapper_all_out_any_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_Tensor_Tensor_pow(const at::Tensor & self, const at::Tensor & exponent) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::pow(self, exponent);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_Tensor_out_pow_out(const at::Tensor & self, const at::Tensor & exponent, at::Tensor & out) {
  auto wrapper_Tensor_Tensor_out_pow_out_tmp = wrapper_Tensor_Tensor_pow(self, exponent);
  at::_copy_from_and_resize(wrapper_Tensor_Tensor_out_pow_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Tensor_pow_(at::Tensor & self, const at::Tensor & exponent) {
  auto wrapper_Tensor_pow__tmp = wrapper_Tensor_Tensor_pow(self, exponent);
  at::_copy_from(wrapper_Tensor_pow__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper_Scalar_pow(const at::Scalar & self, const at::Tensor & exponent) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::pow(self, exponent);
}

} // anonymous namespace
at::Tensor & wrapper_Scalar_out_pow_out(const at::Scalar & self, const at::Tensor & exponent, at::Tensor & out) {
  auto wrapper_Scalar_out_pow_out_tmp = wrapper_Scalar_pow(self, exponent);
  at::_copy_from_and_resize(wrapper_Scalar_out_pow_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_Tensor_Scalar_pow(const at::Tensor & self, const at::Scalar & exponent) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::pow(self, exponent);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_Scalar_out_pow_out(const at::Tensor & self, const at::Scalar & exponent, at::Tensor & out) {
  auto wrapper_Tensor_Scalar_out_pow_out_tmp = wrapper_Tensor_Scalar_pow(self, exponent);
  at::_copy_from_and_resize(wrapper_Tensor_Scalar_out_pow_out_tmp, out);
  return out;
}
at::Tensor & wrapper_Scalar_pow_(at::Tensor & self, const at::Scalar & exponent) {
  auto wrapper_Scalar_pow__tmp = wrapper_Tensor_Scalar_pow(self, exponent);
  at::_copy_from(wrapper_Scalar_pow__tmp, self);
  return self;
}
namespace {

at::Tensor & wrapper__normal_(at::Tensor & self, double mean, double std, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::normal_(self, mean, std, generator);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_Tensor_float_normal(const at::Tensor & mean, double std, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::normal(mean, std, generator);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_float_out_normal_out(const at::Tensor & mean, double std, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Tensor_float_out_normal_out_tmp = wrapper_Tensor_float_normal(mean, std, generator);
  at::_copy_from_and_resize(wrapper_Tensor_float_out_normal_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_float_Tensor_normal(double mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::normal(mean, std, generator);
}

} // anonymous namespace
at::Tensor & wrapper_float_Tensor_out_normal_out(double mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_float_Tensor_out_normal_out_tmp = wrapper_float_Tensor_normal(mean, std, generator);
  at::_copy_from_and_resize(wrapper_float_Tensor_out_normal_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper_Tensor_Tensor_normal(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::normal(mean, std, generator);
}

} // anonymous namespace
at::Tensor & wrapper_Tensor_Tensor_out_normal_out(const at::Tensor & mean, const at::Tensor & std, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_Tensor_Tensor_out_normal_out_tmp = wrapper_Tensor_Tensor_normal(mean, std, generator);
  at::_copy_from_and_resize(wrapper_Tensor_Tensor_out_normal_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__alias(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::alias(self);
}

} // anonymous namespace
namespace {

void wrapper___amp_foreach_non_finite_check_and_unscale_(at::TensorList self, at::Tensor & found_inf, const at::Tensor & inv_scale) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_amp_foreach_non_finite_check_and_unscale_(self, found_inf, inv_scale);
}

} // anonymous namespace
namespace {

at::Tensor & wrapper___amp_update_scale_(at::Tensor & self, at::Tensor & growth_tracker, const at::Tensor & found_inf, double scale_growth_factor, double scale_backoff_factor, int64_t growth_interval) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_amp_update_scale_(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__mse_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mse_loss(self, target, reduction);
}

} // anonymous namespace
at::Tensor & wrapper_out_mse_loss_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & out) {
  auto wrapper_out_mse_loss_out_tmp = wrapper__mse_loss(self, target, reduction);
  at::_copy_from_and_resize(wrapper_out_mse_loss_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__mse_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::mse_loss_backward(grad_output, self, target, reduction);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_mse_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, at::Tensor & grad_input) {
  auto wrapper_grad_input_mse_loss_backward_out_tmp = wrapper__mse_loss_backward(grad_output, self, target, reduction);
  at::_copy_from_and_resize(wrapper_grad_input_mse_loss_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__nll_loss_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::nll_loss_forward(self, target, weight, reduction, ignore_index);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_output_nll_loss_forward_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
  auto wrapper_output_nll_loss_forward_out_tmp = wrapper__nll_loss_forward(self, target, weight, reduction, ignore_index);
  at::_copy_from_and_resize(std::get<0>(wrapper_output_nll_loss_forward_out_tmp), output);
  at::_copy_from_and_resize(std::get<1>(wrapper_output_nll_loss_forward_out_tmp), total_weight);
  return ::std::tuple<at::Tensor &,at::Tensor &>(output, total_weight);
}
namespace {

at::Tensor wrapper__nll_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_nll_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
  auto wrapper_grad_input_nll_loss_backward_out_tmp = wrapper__nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
  at::_copy_from_and_resize(wrapper_grad_input_nll_loss_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__nll_loss2d_forward(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::nll_loss2d_forward(self, target, weight, reduction, ignore_index);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_output_nll_loss2d_forward_out(const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, at::Tensor & output, at::Tensor & total_weight) {
  auto wrapper_output_nll_loss2d_forward_out_tmp = wrapper__nll_loss2d_forward(self, target, weight, reduction, ignore_index);
  at::_copy_from_and_resize(std::get<0>(wrapper_output_nll_loss2d_forward_out_tmp), output);
  at::_copy_from_and_resize(std::get<1>(wrapper_output_nll_loss2d_forward_out_tmp), total_weight);
  return ::std::tuple<at::Tensor &,at::Tensor &>(output, total_weight);
}
namespace {

at::Tensor wrapper__nll_loss2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_nll_loss2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, const c10::optional<at::Tensor> & weight, int64_t reduction, int64_t ignore_index, const at::Tensor & total_weight, at::Tensor & grad_input) {
  auto wrapper_grad_input_nll_loss2d_backward_out_tmp = wrapper__nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight);
  at::_copy_from_and_resize(wrapper_grad_input_nll_loss2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__smooth_l1_loss(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::smooth_l1_loss(self, target, reduction, beta);
}

} // anonymous namespace
at::Tensor & wrapper_out_smooth_l1_loss_out(const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & out) {
  auto wrapper_out_smooth_l1_loss_out_tmp = wrapper__smooth_l1_loss(self, target, reduction, beta);
  at::_copy_from_and_resize(wrapper_out_smooth_l1_loss_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__smooth_l1_loss_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::smooth_l1_loss_backward(grad_output, self, target, reduction, beta);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_smooth_l1_loss_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & target, int64_t reduction, double beta, at::Tensor & grad_input) {
  auto wrapper_grad_input_smooth_l1_loss_backward_out_tmp = wrapper__smooth_l1_loss_backward(grad_output, self, target, reduction, beta);
  at::_copy_from_and_resize(wrapper_grad_input_smooth_l1_loss_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__elu(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::elu(self, alpha, scale, input_scale);
}

} // anonymous namespace
at::Tensor & wrapper_out_elu_out(const at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, at::Tensor & out) {
  auto wrapper_out_elu_out_tmp = wrapper__elu(self, alpha, scale, input_scale);
  at::_copy_from_and_resize(wrapper_out_elu_out_tmp, out);
  return out;
}
namespace {

at::Tensor & wrapper__elu_(at::Tensor & self, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::elu_(self, alpha, scale, input_scale);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__elu_backward(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_elu_backward_out(const at::Tensor & grad_output, const at::Scalar & alpha, const at::Scalar & scale, const at::Scalar & input_scale, bool is_result, const at::Tensor & self_or_result, at::Tensor & grad_input) {
  auto wrapper_grad_input_elu_backward_out_tmp = wrapper__elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result);
  at::_copy_from_and_resize(wrapper_grad_input_elu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__hardsigmoid(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardsigmoid(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_hardsigmoid_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_hardsigmoid_out_tmp = wrapper__hardsigmoid(self);
  at::_copy_from_and_resize(wrapper_out_hardsigmoid_out_tmp, out);
  return out;
}
at::Tensor & wrapper__hardsigmoid_(at::Tensor & self) {
  auto wrapper__hardsigmoid__tmp = wrapper__hardsigmoid(self);
  at::_copy_from(wrapper__hardsigmoid__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__hardsigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardsigmoid_backward(grad_output, self);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_hardsigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::Tensor & grad_input) {
  auto wrapper_grad_input_hardsigmoid_backward_out_tmp = wrapper__hardsigmoid_backward(grad_output, self);
  at::_copy_from_and_resize(wrapper_grad_input_hardsigmoid_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__hardtanh(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardtanh(self, min_val, max_val);
}

} // anonymous namespace
at::Tensor & wrapper_out_hardtanh_out(const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & out) {
  auto wrapper_out_hardtanh_out_tmp = wrapper__hardtanh(self, min_val, max_val);
  at::_copy_from_and_resize(wrapper_out_hardtanh_out_tmp, out);
  return out;
}
at::Tensor & wrapper__hardtanh_(at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
  auto wrapper__hardtanh__tmp = wrapper__hardtanh(self, min_val, max_val);
  at::_copy_from(wrapper__hardtanh__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__hardtanh_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardtanh_backward(grad_output, self, min_val, max_val);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_hardtanh_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & min_val, const at::Scalar & max_val, at::Tensor & grad_input) {
  auto wrapper_grad_input_hardtanh_backward_out_tmp = wrapper__hardtanh_backward(grad_output, self, min_val, max_val);
  at::_copy_from_and_resize(wrapper_grad_input_hardtanh_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__hardswish(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardswish(self);
}

} // anonymous namespace
at::Tensor & wrapper_out_hardswish_out(const at::Tensor & self, at::Tensor & out) {
  auto wrapper_out_hardswish_out_tmp = wrapper__hardswish(self);
  at::_copy_from_and_resize(wrapper_out_hardswish_out_tmp, out);
  return out;
}
at::Tensor & wrapper__hardswish_(at::Tensor & self) {
  auto wrapper__hardswish__tmp = wrapper__hardswish(self);
  at::_copy_from(wrapper__hardswish__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__hardswish_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::hardswish_backward(grad_output, self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__leaky_relu(const at::Tensor & self, const at::Scalar & negative_slope) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::leaky_relu(self, negative_slope);
}

} // anonymous namespace
at::Tensor & wrapper_out_leaky_relu_out(const at::Tensor & self, const at::Scalar & negative_slope, at::Tensor & out) {
  auto wrapper_out_leaky_relu_out_tmp = wrapper__leaky_relu(self, negative_slope);
  at::_copy_from_and_resize(wrapper_out_leaky_relu_out_tmp, out);
  return out;
}
at::Tensor & wrapper__leaky_relu_(at::Tensor & self, const at::Scalar & negative_slope) {
  auto wrapper__leaky_relu__tmp = wrapper__leaky_relu(self, negative_slope);
  at::_copy_from(wrapper__leaky_relu__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__leaky_relu_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::leaky_relu_backward(grad_output, self, negative_slope, self_is_result);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_leaky_relu_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & negative_slope, bool self_is_result, at::Tensor & grad_input) {
  auto wrapper_grad_input_leaky_relu_backward_out_tmp = wrapper__leaky_relu_backward(grad_output, self, negative_slope, self_is_result);
  at::_copy_from_and_resize(wrapper_grad_input_leaky_relu_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__log_sigmoid_forward(const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::log_sigmoid_forward(self);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_output_log_sigmoid_forward_out(const at::Tensor & self, at::Tensor & output, at::Tensor & buffer) {
  auto wrapper_output_log_sigmoid_forward_out_tmp = wrapper__log_sigmoid_forward(self);
  at::_copy_from_and_resize(std::get<0>(wrapper_output_log_sigmoid_forward_out_tmp), output);
  at::_copy_from_and_resize(std::get<1>(wrapper_output_log_sigmoid_forward_out_tmp), buffer);
  return ::std::tuple<at::Tensor &,at::Tensor &>(output, buffer);
}
namespace {

at::Tensor wrapper__log_sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::log_sigmoid_backward(grad_output, self, buffer);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_log_sigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & buffer, at::Tensor & grad_input) {
  auto wrapper_grad_input_log_sigmoid_backward_out_tmp = wrapper__log_sigmoid_backward(grad_output, self, buffer);
  at::_copy_from_and_resize(wrapper_grad_input_log_sigmoid_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__rrelu_with_noise(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::rrelu_with_noise(self, noise, lower, upper, training, generator);
}

} // anonymous namespace
at::Tensor & wrapper_out_rrelu_with_noise_out(const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator, at::Tensor & out) {
  auto wrapper_out_rrelu_with_noise_out_tmp = wrapper__rrelu_with_noise(self, noise, lower, upper, training, generator);
  at::_copy_from_and_resize(wrapper_out_rrelu_with_noise_out_tmp, out);
  return out;
}
at::Tensor & wrapper__rrelu_with_noise_(at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, c10::optional<at::Generator> generator) {
  auto wrapper__rrelu_with_noise__tmp = wrapper__rrelu_with_noise(self, noise, lower, upper, training, generator);
  at::_copy_from(wrapper__rrelu_with_noise__tmp, self);
  return self;
}
namespace {

at::Tensor wrapper__rrelu_with_noise_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & noise, const at::Scalar & lower, const at::Scalar & upper, bool training, bool self_is_result) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::rrelu_with_noise_backward(grad_output, self, noise, lower, upper, training, self_is_result);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__softplus(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::softplus(self, beta, threshold);
}

} // anonymous namespace
at::Tensor & wrapper_out_softplus_out(const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & out) {
  auto wrapper_out_softplus_out_tmp = wrapper__softplus(self, beta, threshold);
  at::_copy_from_and_resize(wrapper_out_softplus_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__softplus_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::softplus_backward(grad_output, self, beta, threshold);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_softplus_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & beta, const at::Scalar & threshold, at::Tensor & grad_input) {
  auto wrapper_grad_input_softplus_backward_out_tmp = wrapper__softplus_backward(grad_output, self, beta, threshold);
  at::_copy_from_and_resize(wrapper_grad_input_softplus_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__softshrink(const at::Tensor & self, const at::Scalar & lambd) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::softshrink(self, lambd);
}

} // anonymous namespace
at::Tensor & wrapper_out_softshrink_out(const at::Tensor & self, const at::Scalar & lambd, at::Tensor & out) {
  auto wrapper_out_softshrink_out_tmp = wrapper__softshrink(self, lambd);
  at::_copy_from_and_resize(wrapper_out_softshrink_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__softshrink_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::softshrink_backward(grad_output, self, lambd);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_softshrink_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Scalar & lambd, at::Tensor & grad_input) {
  auto wrapper_grad_input_softshrink_backward_out_tmp = wrapper__softshrink_backward(grad_output, self, lambd);
  at::_copy_from_and_resize(wrapper_grad_input_softshrink_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper___adaptive_avg_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_adaptive_avg_pool2d(self, output_size);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___adaptive_avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_adaptive_avg_pool2d_backward(grad_output, self);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___adaptive_avg_pool3d(const at::Tensor & self, at::IntArrayRef output_size) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_adaptive_avg_pool3d(self, output_size);
}

} // anonymous namespace
namespace {

at::Tensor wrapper___adaptive_avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::_adaptive_avg_pool3d_backward(grad_output, self);
}

} // anonymous namespace
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__adaptive_max_pool2d(const at::Tensor & self, at::IntArrayRef output_size) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::adaptive_max_pool2d(self, output_size);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_out_adaptive_max_pool2d_out(const at::Tensor & self, at::IntArrayRef output_size, at::Tensor & out, at::Tensor & indices) {
  auto wrapper_out_adaptive_max_pool2d_out_tmp = wrapper__adaptive_max_pool2d(self, output_size);
  at::_copy_from_and_resize(std::get<0>(wrapper_out_adaptive_max_pool2d_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_out_adaptive_max_pool2d_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out, indices);
}
namespace {

at::Tensor wrapper__adaptive_max_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::adaptive_max_pool2d_backward(grad_output, self, indices);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_adaptive_max_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, const at::Tensor & indices, at::Tensor & grad_input) {
  auto wrapper_grad_input_adaptive_max_pool2d_backward_out_tmp = wrapper__adaptive_max_pool2d_backward(grad_output, self, indices);
  at::_copy_from_and_resize(wrapper_grad_input_adaptive_max_pool2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__avg_pool2d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

} // anonymous namespace
at::Tensor & wrapper_out_avg_pool2d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
  auto wrapper_out_avg_pool2d_out_tmp = wrapper__avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
  at::_copy_from_and_resize(wrapper_out_avg_pool2d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__avg_pool2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_avg_pool2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
  auto wrapper_grad_input_avg_pool2d_backward_out_tmp = wrapper__avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
  at::_copy_from_and_resize(wrapper_grad_input_avg_pool2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__avg_pool3d(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::avg_pool3d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

} // anonymous namespace
at::Tensor & wrapper_out_avg_pool3d_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & out) {
  auto wrapper_out_avg_pool3d_out_tmp = wrapper__avg_pool3d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
  at::_copy_from_and_resize(wrapper_out_avg_pool3d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__avg_pool3d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::avg_pool3d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_avg_pool3d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, bool ceil_mode, bool count_include_pad, c10::optional<int64_t> divisor_override, at::Tensor & grad_input) {
  auto wrapper_grad_input_avg_pool3d_backward_out_tmp = wrapper__avg_pool3d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override);
  at::_copy_from_and_resize(wrapper_grad_input_avg_pool3d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__max_pool2d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_out_max_pool2d_with_indices_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
  auto wrapper_out_max_pool2d_with_indices_out_tmp = wrapper__max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
  at::_copy_from_and_resize(std::get<0>(wrapper_out_max_pool2d_with_indices_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_out_max_pool2d_with_indices_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out, indices);
}
namespace {

at::Tensor wrapper__max_pool2d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_max_pool2d_with_indices_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
  auto wrapper_grad_input_max_pool2d_with_indices_backward_out_tmp = wrapper__max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
  at::_copy_from_and_resize(wrapper_grad_input_max_pool2d_with_indices_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

::std::tuple<at::Tensor,at::Tensor> wrapper__max_pool3d_with_indices(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
}

} // anonymous namespace
::std::tuple<at::Tensor &,at::Tensor &> wrapper_out_max_pool3d_with_indices_out(const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, at::Tensor & out, at::Tensor & indices) {
  auto wrapper_out_max_pool3d_with_indices_out_tmp = wrapper__max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode);
  at::_copy_from_and_resize(std::get<0>(wrapper_out_max_pool3d_with_indices_out_tmp), out);
  at::_copy_from_and_resize(std::get<1>(wrapper_out_max_pool3d_with_indices_out_tmp), indices);
  return ::std::tuple<at::Tensor &,at::Tensor &>(out, indices);
}
namespace {

at::Tensor wrapper__max_pool3d_with_indices_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_max_pool3d_with_indices_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef kernel_size, at::IntArrayRef stride, at::IntArrayRef padding, at::IntArrayRef dilation, bool ceil_mode, const at::Tensor & indices, at::Tensor & grad_input) {
  auto wrapper_grad_input_max_pool3d_with_indices_backward_out_tmp = wrapper__max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices);
  at::_copy_from_and_resize(wrapper_grad_input_max_pool3d_with_indices_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__max_unpool2d(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_unpool2d(self, indices, output_size);
}

} // anonymous namespace
at::Tensor & wrapper_out_max_unpool2d_out(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::Tensor & out) {
  auto wrapper_out_max_unpool2d_out_tmp = wrapper__max_unpool2d(self, indices, output_size);
  at::_copy_from_and_resize(wrapper_out_max_unpool2d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__max_unpool3d(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::max_unpool3d(self, indices, output_size, stride, padding);
}

} // anonymous namespace
at::Tensor & wrapper_out_max_unpool3d_out(const at::Tensor & self, const at::Tensor & indices, at::IntArrayRef output_size, at::IntArrayRef stride, at::IntArrayRef padding, at::Tensor & out) {
  auto wrapper_out_max_unpool3d_out_tmp = wrapper__max_unpool3d(self, indices, output_size, stride, padding);
  at::_copy_from_and_resize(wrapper_out_max_unpool3d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__reflection_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::reflection_pad2d(self, padding);
}

} // anonymous namespace
at::Tensor & wrapper_out_reflection_pad2d_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
  auto wrapper_out_reflection_pad2d_out_tmp = wrapper__reflection_pad2d(self, padding);
  at::_copy_from_and_resize(wrapper_out_reflection_pad2d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__reflection_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::reflection_pad2d_backward(grad_output, self, padding);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_reflection_pad2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
  auto wrapper_grad_input_reflection_pad2d_backward_out_tmp = wrapper__reflection_pad2d_backward(grad_output, self, padding);
  at::_copy_from_and_resize(wrapper_grad_input_reflection_pad2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__replication_pad1d(const at::Tensor & self, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::replication_pad1d(self, padding);
}

} // anonymous namespace
at::Tensor & wrapper_out_replication_pad1d_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
  auto wrapper_out_replication_pad1d_out_tmp = wrapper__replication_pad1d(self, padding);
  at::_copy_from_and_resize(wrapper_out_replication_pad1d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__replication_pad1d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::replication_pad1d_backward(grad_output, self, padding);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_replication_pad1d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
  auto wrapper_grad_input_replication_pad1d_backward_out_tmp = wrapper__replication_pad1d_backward(grad_output, self, padding);
  at::_copy_from_and_resize(wrapper_grad_input_replication_pad1d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__replication_pad2d(const at::Tensor & self, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::replication_pad2d(self, padding);
}

} // anonymous namespace
at::Tensor & wrapper_out_replication_pad2d_out(const at::Tensor & self, at::IntArrayRef padding, at::Tensor & out) {
  auto wrapper_out_replication_pad2d_out_tmp = wrapper__replication_pad2d(self, padding);
  at::_copy_from_and_resize(wrapper_out_replication_pad2d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__replication_pad2d_backward(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::replication_pad2d_backward(grad_output, self, padding);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_replication_pad2d_backward_out(const at::Tensor & grad_output, const at::Tensor & self, at::IntArrayRef padding, at::Tensor & grad_input) {
  auto wrapper_grad_input_replication_pad2d_backward_out_tmp = wrapper__replication_pad2d_backward(grad_output, self, padding);
  at::_copy_from_and_resize(wrapper_grad_input_replication_pad2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper_vec_upsample_nearest2d(const at::Tensor & input, at::OptionalIntArrayRef output_size, c10::optional<at::ArrayRef<double>> scale_factors) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::upsample_nearest2d(input, output_size, scale_factors);
}

} // anonymous namespace
namespace {

at::Tensor wrapper_vec_upsample_nearest2d_backward(const at::Tensor & grad_output, at::OptionalIntArrayRef output_size, at::IntArrayRef input_size, c10::optional<at::ArrayRef<double>> scale_factors) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::upsample_nearest2d_backward(grad_output, output_size, input_size, scale_factors);
}

} // anonymous namespace
namespace {

at::Tensor wrapper__upsample_bilinear2d(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::upsample_bilinear2d(self, output_size, align_corners, scales_h, scales_w);
}

} // anonymous namespace
at::Tensor & wrapper_out_upsample_bilinear2d_out(const at::Tensor & self, at::IntArrayRef output_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
  auto wrapper_out_upsample_bilinear2d_out_tmp = wrapper__upsample_bilinear2d(self, output_size, align_corners, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_out_upsample_bilinear2d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__upsample_bilinear2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::upsample_bilinear2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_upsample_bilinear2d_backward_out(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, bool align_corners, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
  auto wrapper_grad_input_upsample_bilinear2d_backward_out_tmp = wrapper__upsample_bilinear2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_grad_input_upsample_bilinear2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__upsample_nearest2d(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::upsample_nearest2d(self, output_size, scales_h, scales_w);
}

} // anonymous namespace
at::Tensor & wrapper_out_upsample_nearest2d_out(const at::Tensor & self, at::IntArrayRef output_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & out) {
  auto wrapper_out_upsample_nearest2d_out_tmp = wrapper__upsample_nearest2d(self, output_size, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_out_upsample_nearest2d_out_tmp, out);
  return out;
}
namespace {

at::Tensor wrapper__upsample_nearest2d_backward(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::upsample_nearest2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_upsample_nearest2d_backward_out(const at::Tensor & grad_output, at::IntArrayRef output_size, at::IntArrayRef input_size, c10::optional<double> scales_h, c10::optional<double> scales_w, at::Tensor & grad_input) {
  auto wrapper_grad_input_upsample_nearest2d_backward_out_tmp = wrapper__upsample_nearest2d_backward(grad_output, output_size, input_size, scales_h, scales_w);
  at::_copy_from_and_resize(wrapper_grad_input_upsample_nearest2d_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__sigmoid_backward(const at::Tensor & grad_output, const at::Tensor & output) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::sigmoid_backward(grad_output, output);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_sigmoid_backward_out(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
  auto wrapper_grad_input_sigmoid_backward_out_tmp = wrapper__sigmoid_backward(grad_output, output);
  at::_copy_from_and_resize(wrapper_grad_input_sigmoid_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__tanh_backward(const at::Tensor & grad_output, const at::Tensor & output) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::tanh_backward(grad_output, output);
}

} // anonymous namespace
at::Tensor & wrapper_grad_input_tanh_backward_out(const at::Tensor & grad_output, const at::Tensor & output, at::Tensor & grad_input) {
  auto wrapper_grad_input_tanh_backward_out_tmp = wrapper__tanh_backward(grad_output, output);
  at::_copy_from_and_resize(wrapper_grad_input_tanh_backward_out_tmp, grad_input);
  return grad_input;
}
namespace {

at::Tensor wrapper__ger(const at::Tensor & self, const at::Tensor & vec2) {
    // No device check


  // DeviceGuard omitted
  return torch_xla::XLANativeFunctions::ger(self, vec2);
}

} // anonymous namespace
at::Tensor & wrapper_out_ger_out(const at::Tensor & self, const at::Tensor & vec2, at::Tensor & out) {
  auto wrapper_out_ger_out_tmp = wrapper__ger(self, vec2);
  at::_copy_from_and_resize(wrapper_out_ger_out_tmp, out);
  return out;
}

TORCH_LIBRARY_IMPL(aten, XLA, m) {
    m.impl("abs",
    TORCH_FN(wrapper__abs));
    m.impl("abs.out",
    TORCH_FN(wrapper_out_abs_out));
    m.impl("abs_",
    TORCH_FN(wrapper__abs_));
    m.impl("sgn",
    TORCH_FN(wrapper__sgn));
    m.impl("sgn.out",
    TORCH_FN(wrapper_out_sgn_out));
    m.impl("sgn_",
    TORCH_FN(wrapper__sgn_));
    m.impl("acos",
    TORCH_FN(wrapper__acos));
    m.impl("acos.out",
    TORCH_FN(wrapper_out_acos_out));
    m.impl("acos_",
    TORCH_FN(wrapper__acos_));
    m.impl("add.Tensor",
    TORCH_FN(wrapper_Tensor_add));
    m.impl("add.out",
    TORCH_FN(wrapper_out_add_out));
    m.impl("add_.Tensor",
    TORCH_FN(wrapper_Tensor_add_));
    m.impl("add.Scalar",
    TORCH_FN(wrapper_Scalar_add));
    m.impl("add.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_add_out));
    m.impl("add_.Scalar",
    TORCH_FN(wrapper_Scalar_add_));
    m.impl("all.dim",
    TORCH_FN(wrapper_dim_all));
    m.impl("all.out",
    TORCH_FN(wrapper_out_all_out));
    m.impl("any.dim",
    TORCH_FN(wrapper_dim_any));
    m.impl("any.out",
    TORCH_FN(wrapper_out_any_out));
    m.impl("arange.start_out",
    TORCH_FN(wrapper_start_out_arange_out));
    m.impl("argmax",
    TORCH_FN(wrapper__argmax));
    m.impl("argmax.out",
    TORCH_FN(wrapper_out_argmax_out));
    m.impl("argmin",
    TORCH_FN(wrapper__argmin));
    m.impl("argmin.out",
    TORCH_FN(wrapper_out_argmin_out));
    m.impl("acosh",
    TORCH_FN(wrapper__acosh));
    m.impl("acosh.out",
    TORCH_FN(wrapper_out_acosh_out));
    m.impl("acosh_",
    TORCH_FN(wrapper__acosh_));
    m.impl("asinh",
    TORCH_FN(wrapper__asinh));
    m.impl("asinh.out",
    TORCH_FN(wrapper_out_asinh_out));
    m.impl("asinh_",
    TORCH_FN(wrapper__asinh_));
    m.impl("atanh",
    TORCH_FN(wrapper__atanh));
    m.impl("atanh.out",
    TORCH_FN(wrapper_out_atanh_out));
    m.impl("atanh_",
    TORCH_FN(wrapper__atanh_));
    m.impl("as_strided",
    TORCH_FN(wrapper__as_strided));
    m.impl("as_strided_",
    TORCH_FN(wrapper__as_strided_));
    m.impl("asin",
    TORCH_FN(wrapper__asin));
    m.impl("asin.out",
    TORCH_FN(wrapper_out_asin_out));
    m.impl("asin_",
    TORCH_FN(wrapper__asin_));
    m.impl("atan",
    TORCH_FN(wrapper__atan));
    m.impl("atan.out",
    TORCH_FN(wrapper_out_atan_out));
    m.impl("atan_",
    TORCH_FN(wrapper__atan_));
    m.impl("baddbmm",
    TORCH_FN(wrapper__baddbmm));
    m.impl("baddbmm.out",
    TORCH_FN(wrapper_out_baddbmm_out));
    m.impl("baddbmm_",
    TORCH_FN(wrapper__baddbmm_));
    m.impl("bernoulli",
    TORCH_FN(wrapper__bernoulli));
    m.impl("bernoulli.out",
    TORCH_FN(wrapper_out_bernoulli_out));
    m.impl("bernoulli_.Tensor",
    TORCH_FN(wrapper_Tensor_bernoulli_));
    m.impl("bernoulli_.float",
    TORCH_FN(wrapper_float_bernoulli_));
    m.impl("binary_cross_entropy",
    TORCH_FN(wrapper__binary_cross_entropy));
    m.impl("binary_cross_entropy.out",
    TORCH_FN(wrapper_out_binary_cross_entropy_out));
    m.impl("binary_cross_entropy_backward",
    TORCH_FN(wrapper__binary_cross_entropy_backward));
    m.impl("binary_cross_entropy_backward.grad_input",
    TORCH_FN(wrapper_grad_input_binary_cross_entropy_backward_out));
    m.impl("binary_cross_entropy_with_logits",
    TORCH_FN(wrapper__binary_cross_entropy_with_logits));
    m.impl("bitwise_not",
    TORCH_FN(wrapper__bitwise_not));
    m.impl("bitwise_not.out",
    TORCH_FN(wrapper_out_bitwise_not_out));
    m.impl("bitwise_not_",
    TORCH_FN(wrapper__bitwise_not_));
    m.impl("logical_not",
    TORCH_FN(wrapper__logical_not));
    m.impl("logical_not.out",
    TORCH_FN(wrapper_out_logical_not_out));
    m.impl("logical_not_",
    TORCH_FN(wrapper__logical_not_));
    m.impl("logical_xor",
    TORCH_FN(wrapper__logical_xor));
    m.impl("logical_xor.out",
    TORCH_FN(wrapper_out_logical_xor_out));
    m.impl("logical_xor_",
    TORCH_FN(wrapper__logical_xor_));
    m.impl("logical_and",
    TORCH_FN(wrapper__logical_and));
    m.impl("logical_and.out",
    TORCH_FN(wrapper_out_logical_and_out));
    m.impl("logical_and_",
    TORCH_FN(wrapper__logical_and_));
    m.impl("logical_or",
    TORCH_FN(wrapper__logical_or));
    m.impl("logical_or.out",
    TORCH_FN(wrapper_out_logical_or_out));
    m.impl("logical_or_",
    TORCH_FN(wrapper__logical_or_));
    m.impl("bmm",
    TORCH_FN(wrapper__bmm));
    m.impl("bmm.out",
    TORCH_FN(wrapper_out_bmm_out));
    m.impl("cat",
    TORCH_FN(wrapper__cat));
    m.impl("cat.out",
    TORCH_FN(wrapper_out_cat_out));
    m.impl("ceil",
    TORCH_FN(wrapper__ceil));
    m.impl("ceil.out",
    TORCH_FN(wrapper_out_ceil_out));
    m.impl("ceil_",
    TORCH_FN(wrapper__ceil_));
    m.impl("clamp",
    TORCH_FN(wrapper__clamp));
    m.impl("clamp.out",
    TORCH_FN(wrapper_out_clamp_out));
    m.impl("clamp_",
    TORCH_FN(wrapper__clamp_));
    m.impl("clamp.Tensor",
    TORCH_FN(wrapper_Tensor_clamp));
    m.impl("clamp.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_clamp_out));
    m.impl("clamp_.Tensor",
    TORCH_FN(wrapper_Tensor_clamp_));
    m.impl("clamp_max",
    TORCH_FN(wrapper__clamp_max));
    m.impl("clamp_max.out",
    TORCH_FN(wrapper_out_clamp_max_out));
    m.impl("clamp_max_",
    TORCH_FN(wrapper__clamp_max_));
    m.impl("clamp_max.Tensor",
    TORCH_FN(wrapper_Tensor_clamp_max));
    m.impl("clamp_max.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_clamp_max_out));
    m.impl("clamp_max_.Tensor",
    TORCH_FN(wrapper_Tensor_clamp_max_));
    m.impl("clamp_min",
    TORCH_FN(wrapper__clamp_min));
    m.impl("clamp_min.out",
    TORCH_FN(wrapper_out_clamp_min_out));
    m.impl("clamp_min_",
    TORCH_FN(wrapper__clamp_min_));
    m.impl("clamp_min.Tensor",
    TORCH_FN(wrapper_Tensor_clamp_min));
    m.impl("clamp_min.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_clamp_min_out));
    m.impl("clamp_min_.Tensor",
    TORCH_FN(wrapper_Tensor_clamp_min_));
    m.impl("constant_pad_nd",
    TORCH_FN(wrapper__constant_pad_nd));
    m.impl("convolution_overrideable",
    TORCH_FN(wrapper__convolution_overrideable));
    m.impl("convolution_backward_overrideable",
    TORCH_FN(wrapper__convolution_backward_overrideable));
    m.impl("_copy_from",
    TORCH_FN(wrapper___copy_from));
    m.impl("_copy_from_and_resize",
    TORCH_FN(wrapper___copy_from_and_resize));
    m.impl("cos",
    TORCH_FN(wrapper__cos));
    m.impl("cos.out",
    TORCH_FN(wrapper_out_cos_out));
    m.impl("cos_",
    TORCH_FN(wrapper__cos_));
    m.impl("cosh",
    TORCH_FN(wrapper__cosh));
    m.impl("cosh.out",
    TORCH_FN(wrapper_out_cosh_out));
    m.impl("cosh_",
    TORCH_FN(wrapper__cosh_));
    m.impl("cumprod",
    TORCH_FN(wrapper__cumprod));
    m.impl("cumprod.out",
    TORCH_FN(wrapper_out_cumprod_out));
    m.impl("cumprod_",
    TORCH_FN(wrapper__cumprod_));
    m.impl("cumsum",
    TORCH_FN(wrapper__cumsum));
    m.impl("cumsum.out",
    TORCH_FN(wrapper_out_cumsum_out));
    m.impl("cumsum_",
    TORCH_FN(wrapper__cumsum_));
    m.impl("diagonal",
    TORCH_FN(wrapper__diagonal));
    m.impl("div.Tensor",
    TORCH_FN(wrapper_Tensor_div));
    m.impl("div.out",
    TORCH_FN(wrapper_out_div_out));
    m.impl("div_.Tensor",
    TORCH_FN(wrapper_Tensor_div_));
    m.impl("div.Tensor_mode",
    TORCH_FN(wrapper_Tensor_mode_div));
    m.impl("div.out_mode",
    TORCH_FN(wrapper_out_mode_div_out));
    m.impl("div_.Tensor_mode",
    TORCH_FN(wrapper_Tensor_mode_div_));
    m.impl("div.Scalar",
    TORCH_FN(wrapper_Scalar_div));
    m.impl("div.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_div_out));
    m.impl("div_.Scalar",
    TORCH_FN(wrapper_Scalar_div_));
    m.impl("dot",
    TORCH_FN(wrapper__dot));
    m.impl("dot.out",
    TORCH_FN(wrapper_out_dot_out));
    m.impl("embedding",
    TORCH_FN(wrapper__embedding));
    m.impl("embedding_dense_backward",
    TORCH_FN(wrapper__embedding_dense_backward));
    m.impl("empty.memory_format",
    TORCH_FN(wrapper_memory_format_empty));
    m.impl("empty.out",
    TORCH_FN(wrapper_out_empty_out));
    m.impl("resize_",
    TORCH_FN(wrapper__resize_));
    m.impl("empty_strided",
    TORCH_FN(wrapper__empty_strided));
    m.impl("erf",
    TORCH_FN(wrapper__erf));
    m.impl("erf.out",
    TORCH_FN(wrapper_out_erf_out));
    m.impl("erf_",
    TORCH_FN(wrapper__erf_));
    m.impl("erfc",
    TORCH_FN(wrapper__erfc));
    m.impl("erfc.out",
    TORCH_FN(wrapper_out_erfc_out));
    m.impl("erfc_",
    TORCH_FN(wrapper__erfc_));
    m.impl("exp",
    TORCH_FN(wrapper__exp));
    m.impl("exp.out",
    TORCH_FN(wrapper_out_exp_out));
    m.impl("exp_",
    TORCH_FN(wrapper__exp_));
    m.impl("expm1",
    TORCH_FN(wrapper__expm1));
    m.impl("expm1.out",
    TORCH_FN(wrapper_out_expm1_out));
    m.impl("expm1_",
    TORCH_FN(wrapper__expm1_));
    m.impl("expand.SymInt",
    TORCH_FN(wrapper_SymInt_expand));
    m.impl("expand",
    TORCH_FN(wrapper__expand));
    m.impl("eye.out",
    TORCH_FN(wrapper_out_eye_out));
    m.impl("eye.m_out",
    TORCH_FN(wrapper_m_out_eye_out));
    m.impl("fill_.Scalar",
    TORCH_FN(wrapper_Scalar_fill_));
    m.impl("fill_.Tensor",
    TORCH_FN(wrapper_Tensor_fill_));
    m.impl("floor",
    TORCH_FN(wrapper__floor));
    m.impl("floor.out",
    TORCH_FN(wrapper_out_floor_out));
    m.impl("floor_",
    TORCH_FN(wrapper__floor_));
    m.impl("frac",
    TORCH_FN(wrapper__frac));
    m.impl("frac.out",
    TORCH_FN(wrapper_out_frac_out));
    m.impl("frac_",
    TORCH_FN(wrapper__frac_));
    m.impl("index.Tensor",
    TORCH_FN(wrapper_Tensor_index));
    m.impl("index.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_index_out));
    m.impl("index_copy",
    TORCH_FN(wrapper__index_copy));
    m.impl("index_copy.out",
    TORCH_FN(wrapper_out_index_copy_out));
    m.impl("index_copy_",
    TORCH_FN(wrapper__index_copy_));
    m.impl("index_put_",
    TORCH_FN(wrapper__index_put_));
    m.impl("_index_put_impl_",
    TORCH_FN(wrapper___index_put_impl_));
    m.impl("inverse",
    TORCH_FN(wrapper__inverse));
    m.impl("inverse.out",
    TORCH_FN(wrapper_out_inverse_out));
    m.impl("isnan",
    TORCH_FN(wrapper__isnan));
    m.impl("kl_div",
    TORCH_FN(wrapper__kl_div));
    m.impl("kl_div_backward",
    TORCH_FN(wrapper__kl_div_backward));
    m.impl("kthvalue",
    TORCH_FN(wrapper__kthvalue));
    m.impl("kthvalue.values",
    TORCH_FN(wrapper_values_kthvalue_out));
    m.impl("nan_to_num",
    TORCH_FN(wrapper__nan_to_num));
    m.impl("nan_to_num.out",
    TORCH_FN(wrapper_out_nan_to_num_out));
    m.impl("nan_to_num_",
    TORCH_FN(wrapper__nan_to_num_));
    m.impl("linspace",
    TORCH_FN(wrapper__linspace));
    m.impl("linspace.out",
    TORCH_FN(wrapper_out_linspace_out));
    m.impl("log",
    TORCH_FN(wrapper__log));
    m.impl("log.out",
    TORCH_FN(wrapper_out_log_out));
    m.impl("log_",
    TORCH_FN(wrapper__log_));
    m.impl("log10",
    TORCH_FN(wrapper__log10));
    m.impl("log10.out",
    TORCH_FN(wrapper_out_log10_out));
    m.impl("log10_",
    TORCH_FN(wrapper__log10_));
    m.impl("log1p",
    TORCH_FN(wrapper__log1p));
    m.impl("log1p.out",
    TORCH_FN(wrapper_out_log1p_out));
    m.impl("log1p_",
    TORCH_FN(wrapper__log1p_));
    m.impl("log2",
    TORCH_FN(wrapper__log2));
    m.impl("log2.out",
    TORCH_FN(wrapper_out_log2_out));
    m.impl("log2_",
    TORCH_FN(wrapper__log2_));
    m.impl("xlogy.Tensor",
    TORCH_FN(wrapper_Tensor_xlogy));
    m.impl("xlogy.OutTensor",
    TORCH_FN(wrapper_OutTensor_xlogy_out));
    m.impl("xlogy_.Tensor",
    TORCH_FN(wrapper_Tensor_xlogy_));
    m.impl("logdet",
    TORCH_FN(wrapper__logdet));
    m.impl("_log_softmax",
    TORCH_FN(wrapper___log_softmax));
    m.impl("_log_softmax.out",
    TORCH_FN(wrapper_out__log_softmax_out));
    m.impl("_log_softmax_backward_data",
    TORCH_FN(wrapper___log_softmax_backward_data));
    m.impl("_log_softmax_backward_data.out",
    TORCH_FN(wrapper_out__log_softmax_backward_data_out));
    m.impl("logsumexp",
    TORCH_FN(wrapper__logsumexp));
    m.impl("logsumexp.out",
    TORCH_FN(wrapper_out_logsumexp_out));
    m.impl("max.dim",
    TORCH_FN(wrapper_dim_max));
    m.impl("max.dim_max",
    TORCH_FN(wrapper_dim_max_max_out));
    m.impl("amax",
    TORCH_FN(wrapper__amax));
    m.impl("amax.out",
    TORCH_FN(wrapper_out_amax_out));
    m.impl("mean",
    TORCH_FN(wrapper__mean));
    m.impl("mean.dim",
    TORCH_FN(wrapper_dim_mean));
    m.impl("mean.out",
    TORCH_FN(wrapper_out_mean_out));
    m.impl("min.dim",
    TORCH_FN(wrapper_dim_min));
    m.impl("min.dim_min",
    TORCH_FN(wrapper_dim_min_min_out));
    m.impl("amin",
    TORCH_FN(wrapper__amin));
    m.impl("amin.out",
    TORCH_FN(wrapper_out_amin_out));
    m.impl("mm",
    TORCH_FN(wrapper__mm));
    m.impl("mm.out",
    TORCH_FN(wrapper_out_mm_out));
    m.impl("mul.Tensor",
    TORCH_FN(wrapper_Tensor_mul));
    m.impl("mul.out",
    TORCH_FN(wrapper_out_mul_out));
    m.impl("mul_.Tensor",
    TORCH_FN(wrapper_Tensor_mul_));
    m.impl("mul.Scalar",
    TORCH_FN(wrapper_Scalar_mul));
    m.impl("mul.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_mul_out));
    m.impl("mul_.Scalar",
    TORCH_FN(wrapper_Scalar_mul_));
    m.impl("mv",
    TORCH_FN(wrapper__mv));
    m.impl("mv.out",
    TORCH_FN(wrapper_out_mv_out));
    m.impl("native_batch_norm",
    TORCH_FN(wrapper__native_batch_norm));
    m.impl("native_batch_norm.out",
    TORCH_FN(wrapper_out_native_batch_norm_out));
    m.impl("native_batch_norm_backward",
    TORCH_FN(wrapper__native_batch_norm_backward));
    m.impl("permute",
    TORCH_FN(wrapper__permute));
    m.impl("reciprocal",
    TORCH_FN(wrapper__reciprocal));
    m.impl("reciprocal.out",
    TORCH_FN(wrapper_out_reciprocal_out));
    m.impl("reciprocal_",
    TORCH_FN(wrapper__reciprocal_));
    m.impl("neg",
    TORCH_FN(wrapper__neg));
    m.impl("neg.out",
    TORCH_FN(wrapper_out_neg_out));
    m.impl("neg_",
    TORCH_FN(wrapper__neg_));
    m.impl("repeat",
    TORCH_FN(wrapper__repeat));
    m.impl("round",
    TORCH_FN(wrapper__round));
    m.impl("round.out",
    TORCH_FN(wrapper_out_round_out));
    m.impl("round_",
    TORCH_FN(wrapper__round_));
    m.impl("relu",
    TORCH_FN(wrapper__relu));
    m.impl("relu.out",
    TORCH_FN(wrapper_out_relu_out));
    m.impl("relu_",
    TORCH_FN(wrapper__relu_));
    m.impl("prelu",
    TORCH_FN(wrapper__prelu));
    m.impl("gelu",
    TORCH_FN(wrapper__gelu));
    m.impl("gelu.out",
    TORCH_FN(wrapper_out_gelu_out));
    m.impl("gelu_",
    TORCH_FN(wrapper__gelu_));
    m.impl("gelu_backward",
    TORCH_FN(wrapper__gelu_backward));
    m.impl("gelu_backward.grad_input",
    TORCH_FN(wrapper_grad_input_gelu_backward_out));
    m.impl("hardshrink",
    TORCH_FN(wrapper__hardshrink));
    m.impl("hardshrink.out",
    TORCH_FN(wrapper_out_hardshrink_out));
    m.impl("hardshrink_backward",
    TORCH_FN(wrapper__hardshrink_backward));
    m.impl("hardshrink_backward.grad_input",
    TORCH_FN(wrapper_grad_input_hardshrink_backward_out));
    m.impl("rsqrt",
    TORCH_FN(wrapper__rsqrt));
    m.impl("rsqrt.out",
    TORCH_FN(wrapper_out_rsqrt_out));
    m.impl("rsqrt_",
    TORCH_FN(wrapper__rsqrt_));
    m.impl("select.int",
    TORCH_FN(wrapper_int_select));
    m.impl("selu",
    TORCH_FN(wrapper__selu));
    m.impl("selu_",
    TORCH_FN(wrapper__selu_));
    m.impl("celu",
    TORCH_FN(wrapper__celu));
    m.impl("celu.out",
    TORCH_FN(wrapper_out_celu_out));
    m.impl("celu_",
    TORCH_FN(wrapper__celu_));
    m.impl("silu",
    TORCH_FN(wrapper__silu));
    m.impl("silu.out",
    TORCH_FN(wrapper_out_silu_out));
    m.impl("silu_",
    TORCH_FN(wrapper__silu_));
    m.impl("silu_backward",
    TORCH_FN(wrapper__silu_backward));
    m.impl("silu_backward.grad_input",
    TORCH_FN(wrapper_grad_input_silu_backward_out));
    m.impl("mish",
    TORCH_FN(wrapper__mish));
    m.impl("mish.out",
    TORCH_FN(wrapper_out_mish_out));
    m.impl("mish_",
    TORCH_FN(wrapper__mish_));
    m.impl("sigmoid",
    TORCH_FN(wrapper__sigmoid));
    m.impl("sigmoid.out",
    TORCH_FN(wrapper_out_sigmoid_out));
    m.impl("sigmoid_",
    TORCH_FN(wrapper__sigmoid_));
    m.impl("sin",
    TORCH_FN(wrapper__sin));
    m.impl("sin.out",
    TORCH_FN(wrapper_out_sin_out));
    m.impl("sin_",
    TORCH_FN(wrapper__sin_));
    m.impl("sinh",
    TORCH_FN(wrapper__sinh));
    m.impl("sinh.out",
    TORCH_FN(wrapper_out_sinh_out));
    m.impl("sinh_",
    TORCH_FN(wrapper__sinh_));
    m.impl("slice.Tensor",
    TORCH_FN(wrapper_Tensor_slice));
    m.impl("slogdet",
    TORCH_FN(wrapper__slogdet));
    m.impl("_softmax",
    TORCH_FN(wrapper___softmax));
    m.impl("_softmax.out",
    TORCH_FN(wrapper_out__softmax_out));
    m.impl("_softmax_backward_data",
    TORCH_FN(wrapper___softmax_backward_data));
    m.impl("_softmax_backward_data.out",
    TORCH_FN(wrapper_out__softmax_backward_data_out));
    m.impl("split.Tensor",
    TORCH_FN(wrapper_Tensor_split));
    m.impl("split_with_sizes",
    TORCH_FN(wrapper__split_with_sizes));
    m.impl("squeeze",
    TORCH_FN(wrapper__squeeze));
    m.impl("squeeze_",
    TORCH_FN(wrapper__squeeze_));
    m.impl("squeeze.dim",
    TORCH_FN(wrapper_dim_squeeze));
    m.impl("squeeze_.dim",
    TORCH_FN(wrapper_dim_squeeze_));
    m.impl("stack",
    TORCH_FN(wrapper__stack));
    m.impl("stack.out",
    TORCH_FN(wrapper_out_stack_out));
    m.impl("sum",
    TORCH_FN(wrapper__sum));
    m.impl("sum.dim_IntList",
    TORCH_FN(wrapper_dim_IntList_sum));
    m.impl("sum.IntList_out",
    TORCH_FN(wrapper_IntList_out_sum_out));
    m.impl("sqrt",
    TORCH_FN(wrapper__sqrt));
    m.impl("sqrt.out",
    TORCH_FN(wrapper_out_sqrt_out));
    m.impl("sqrt_",
    TORCH_FN(wrapper__sqrt_));
    m.impl("std",
    TORCH_FN(wrapper__std));
    m.impl("std.dim",
    TORCH_FN(wrapper_dim_std));
    m.impl("std.out",
    TORCH_FN(wrapper_out_std_out));
    m.impl("std.correction",
    TORCH_FN(wrapper_correction_std));
    m.impl("std.correction_out",
    TORCH_FN(wrapper_correction_out_std_out));
    m.impl("std_mean.correction",
    TORCH_FN(wrapper_correction_std_mean));
    m.impl("prod",
    TORCH_FN(wrapper__prod));
    m.impl("prod.dim_int",
    TORCH_FN(wrapper_dim_int_prod));
    m.impl("prod.int_out",
    TORCH_FN(wrapper_int_out_prod_out));
    m.impl("t",
    TORCH_FN(wrapper__t));
    m.impl("t_",
    TORCH_FN(wrapper__t_));
    m.impl("tan",
    TORCH_FN(wrapper__tan));
    m.impl("tan.out",
    TORCH_FN(wrapper_out_tan_out));
    m.impl("tan_",
    TORCH_FN(wrapper__tan_));
    m.impl("tanh",
    TORCH_FN(wrapper__tanh));
    m.impl("tanh.out",
    TORCH_FN(wrapper_out_tanh_out));
    m.impl("tanh_",
    TORCH_FN(wrapper__tanh_));
    m.impl("threshold",
    TORCH_FN(wrapper__threshold));
    m.impl("threshold.out",
    TORCH_FN(wrapper_out_threshold_out));
    m.impl("threshold_",
    TORCH_FN(wrapper__threshold_));
    m.impl("threshold_backward",
    TORCH_FN(wrapper__threshold_backward));
    m.impl("threshold_backward.grad_input",
    TORCH_FN(wrapper_grad_input_threshold_backward_out));
    m.impl("transpose.int",
    TORCH_FN(wrapper_int_transpose));
    m.impl("transpose_",
    TORCH_FN(wrapper__transpose_));
    m.impl("flip",
    TORCH_FN(wrapper__flip));
    m.impl("roll",
    TORCH_FN(wrapper__roll));
    m.impl("_trilinear",
    TORCH_FN(wrapper___trilinear));
    m.impl("trunc",
    TORCH_FN(wrapper__trunc));
    m.impl("trunc.out",
    TORCH_FN(wrapper_out_trunc_out));
    m.impl("trunc_",
    TORCH_FN(wrapper__trunc_));
    m.impl("_unsafe_view",
    TORCH_FN(wrapper___unsafe_view));
    m.impl("unsqueeze",
    TORCH_FN(wrapper__unsqueeze));
    m.impl("unsqueeze_",
    TORCH_FN(wrapper__unsqueeze_));
    m.impl("var.correction",
    TORCH_FN(wrapper_correction_var));
    m.impl("var.correction_out",
    TORCH_FN(wrapper_correction_out_var_out));
    m.impl("var_mean.correction",
    TORCH_FN(wrapper_correction_var_mean));
    m.impl("where.self",
    TORCH_FN(wrapper_self_where));
    m.impl("where.self_out",
    TORCH_FN(wrapper_self_out_where_out));
    m.impl("norm.ScalarOpt_dtype",
    TORCH_FN(wrapper_ScalarOpt_dtype_norm));
    m.impl("norm.Scalar",
    TORCH_FN(wrapper_Scalar_norm));
    m.impl("norm.ScalarOpt_dim_dtype",
    TORCH_FN(wrapper_ScalarOpt_dim_dtype_norm));
    m.impl("norm.dtype_out",
    TORCH_FN(wrapper_dtype_out_norm_out));
    m.impl("norm.ScalarOpt_dim",
    TORCH_FN(wrapper_ScalarOpt_dim_norm));
    m.impl("norm.out",
    TORCH_FN(wrapper_out_norm_out));
    m.impl("clone",
    TORCH_FN(wrapper__clone));
    m.impl("zero_",
    TORCH_FN(wrapper__zero_));
    m.impl("sub.Tensor",
    TORCH_FN(wrapper_Tensor_sub));
    m.impl("sub.out",
    TORCH_FN(wrapper_out_sub_out));
    m.impl("sub_.Tensor",
    TORCH_FN(wrapper_Tensor_sub_));
    m.impl("sub.Scalar",
    TORCH_FN(wrapper_Scalar_sub));
    m.impl("sub.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_sub_out));
    m.impl("sub_.Scalar",
    TORCH_FN(wrapper_Scalar_sub_));
    m.impl("rsub.Tensor",
    TORCH_FN(wrapper_Tensor_rsub));
    m.impl("rsub.Scalar",
    TORCH_FN(wrapper_Scalar_rsub));
    m.impl("addmm",
    TORCH_FN(wrapper__addmm));
    m.impl("addmm.out",
    TORCH_FN(wrapper_out_addmm_out));
    m.impl("addmm_",
    TORCH_FN(wrapper__addmm_));
    m.impl("_to_cpu",
    TORCH_FN(wrapper___to_cpu));
    m.impl("unbind.int",
    TORCH_FN(wrapper_int_unbind));
    m.impl("_local_scalar_dense",
    TORCH_FN(wrapper___local_scalar_dense));
    m.impl("_pack_padded_sequence",
    TORCH_FN(wrapper___pack_padded_sequence));
    m.impl("masked_fill_.Scalar",
    TORCH_FN(wrapper_Scalar_masked_fill_));
    m.impl("masked_fill_.Tensor",
    TORCH_FN(wrapper_Tensor_masked_fill_));
    m.impl("masked_scatter_",
    TORCH_FN(wrapper__masked_scatter_));
    m.impl("view",
    TORCH_FN(wrapper__view));
    m.impl("put_",
    TORCH_FN(wrapper__put_));
    m.impl("index_add",
    TORCH_FN(wrapper__index_add));
    m.impl("index_add.out",
    TORCH_FN(wrapper_out_index_add_out));
    m.impl("index_add_",
    TORCH_FN(wrapper__index_add_));
    m.impl("index_fill_.int_Scalar",
    TORCH_FN(wrapper_int_Scalar_index_fill_));
    m.impl("index_fill_.int_Tensor",
    TORCH_FN(wrapper_int_Tensor_index_fill_));
    m.impl("scatter.src",
    TORCH_FN(wrapper_src_scatter));
    m.impl("scatter.src_out",
    TORCH_FN(wrapper_src_out_scatter_out));
    m.impl("scatter_.src",
    TORCH_FN(wrapper_src_scatter_));
    m.impl("scatter.value",
    TORCH_FN(wrapper_value_scatter));
    m.impl("scatter.value_out",
    TORCH_FN(wrapper_value_out_scatter_out));
    m.impl("scatter_.value",
    TORCH_FN(wrapper_value_scatter_));
    m.impl("scatter.reduce",
    TORCH_FN(wrapper_reduce_scatter));
    m.impl("scatter.reduce_out",
    TORCH_FN(wrapper_reduce_out_scatter_out));
    m.impl("scatter_.reduce",
    TORCH_FN(wrapper_reduce_scatter_));
    m.impl("scatter.value_reduce",
    TORCH_FN(wrapper_value_reduce_scatter));
    m.impl("scatter.value_reduce_out",
    TORCH_FN(wrapper_value_reduce_out_scatter_out));
    m.impl("scatter_.value_reduce",
    TORCH_FN(wrapper_value_reduce_scatter_));
    m.impl("scatter_add",
    TORCH_FN(wrapper__scatter_add));
    m.impl("scatter_add.out",
    TORCH_FN(wrapper_out_scatter_add_out));
    m.impl("scatter_add_",
    TORCH_FN(wrapper__scatter_add_));
    m.impl("eq.Scalar",
    TORCH_FN(wrapper_Scalar_eq));
    m.impl("eq.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_eq_out));
    m.impl("eq_.Scalar",
    TORCH_FN(wrapper_Scalar_eq_));
    m.impl("eq.Tensor",
    TORCH_FN(wrapper_Tensor_eq));
    m.impl("eq.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_eq_out));
    m.impl("eq_.Tensor",
    TORCH_FN(wrapper_Tensor_eq_));
    m.impl("bitwise_and.Tensor",
    TORCH_FN(wrapper_Tensor_bitwise_and));
    m.impl("bitwise_and.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_bitwise_and_out));
    m.impl("bitwise_and_.Tensor",
    TORCH_FN(wrapper_Tensor_bitwise_and_));
    m.impl("bitwise_and.Scalar",
    TORCH_FN(wrapper_Scalar_bitwise_and));
    m.impl("bitwise_and.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_bitwise_and_out));
    m.impl("bitwise_and_.Scalar",
    TORCH_FN(wrapper_Scalar_bitwise_and_));
    m.impl("bitwise_or.Tensor",
    TORCH_FN(wrapper_Tensor_bitwise_or));
    m.impl("bitwise_or.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_bitwise_or_out));
    m.impl("bitwise_or_.Tensor",
    TORCH_FN(wrapper_Tensor_bitwise_or_));
    m.impl("bitwise_or.Scalar",
    TORCH_FN(wrapper_Scalar_bitwise_or));
    m.impl("bitwise_or.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_bitwise_or_out));
    m.impl("bitwise_or_.Scalar",
    TORCH_FN(wrapper_Scalar_bitwise_or_));
    m.impl("bitwise_xor.Tensor",
    TORCH_FN(wrapper_Tensor_bitwise_xor));
    m.impl("bitwise_xor.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_bitwise_xor_out));
    m.impl("bitwise_xor_.Tensor",
    TORCH_FN(wrapper_Tensor_bitwise_xor_));
    m.impl("bitwise_xor.Scalar",
    TORCH_FN(wrapper_Scalar_bitwise_xor));
    m.impl("bitwise_xor.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_bitwise_xor_out));
    m.impl("bitwise_xor_.Scalar",
    TORCH_FN(wrapper_Scalar_bitwise_xor_));
    m.impl("__lshift__.Scalar",
    TORCH_FN(wrapper_Scalar___lshift__));
    m.impl("__lshift__.Scalar_out",
    TORCH_FN(wrapper_Scalar_out___lshift___out));
    m.impl("__ilshift__.Scalar",
    TORCH_FN(wrapper_Scalar___ilshift__));
    m.impl("__lshift__.Tensor",
    TORCH_FN(wrapper_Tensor___lshift__));
    m.impl("__lshift__.Tensor_out",
    TORCH_FN(wrapper_Tensor_out___lshift___out));
    m.impl("__ilshift__.Tensor",
    TORCH_FN(wrapper_Tensor___ilshift__));
    m.impl("__rshift__.Scalar",
    TORCH_FN(wrapper_Scalar___rshift__));
    m.impl("__rshift__.Scalar_out",
    TORCH_FN(wrapper_Scalar_out___rshift___out));
    m.impl("__irshift__.Scalar",
    TORCH_FN(wrapper_Scalar___irshift__));
    m.impl("__rshift__.Tensor",
    TORCH_FN(wrapper_Tensor___rshift__));
    m.impl("__rshift__.Tensor_out",
    TORCH_FN(wrapper_Tensor_out___rshift___out));
    m.impl("__irshift__.Tensor",
    TORCH_FN(wrapper_Tensor___irshift__));
    m.impl("tril",
    TORCH_FN(wrapper__tril));
    m.impl("tril.out",
    TORCH_FN(wrapper_out_tril_out));
    m.impl("tril_",
    TORCH_FN(wrapper__tril_));
    m.impl("triu",
    TORCH_FN(wrapper__triu));
    m.impl("triu.out",
    TORCH_FN(wrapper_out_triu_out));
    m.impl("triu_",
    TORCH_FN(wrapper__triu_));
    m.impl("lerp.Scalar",
    TORCH_FN(wrapper_Scalar_lerp));
    m.impl("lerp.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_lerp_out));
    m.impl("lerp_.Scalar",
    TORCH_FN(wrapper_Scalar_lerp_));
    m.impl("lerp.Tensor",
    TORCH_FN(wrapper_Tensor_lerp));
    m.impl("lerp.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_lerp_out));
    m.impl("lerp_.Tensor",
    TORCH_FN(wrapper_Tensor_lerp_));
    m.impl("random_.from",
    TORCH_FN(wrapper_from_random_));
    m.impl("random_.to",
    TORCH_FN(wrapper_to_random_));
    m.impl("random_",
    TORCH_FN(wrapper__random_));
    m.impl("uniform_",
    TORCH_FN(wrapper__uniform_));
    m.impl("exponential_",
    TORCH_FN(wrapper__exponential_));
    m.impl("diag",
    TORCH_FN(wrapper__diag));
    m.impl("diag.out",
    TORCH_FN(wrapper_out_diag_out));
    m.impl("cross",
    TORCH_FN(wrapper__cross));
    m.impl("cross.out",
    TORCH_FN(wrapper_out_cross_out));
    m.impl("trace",
    TORCH_FN(wrapper__trace));
    m.impl("ne.Scalar",
    TORCH_FN(wrapper_Scalar_ne));
    m.impl("ne.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_ne_out));
    m.impl("ne_.Scalar",
    TORCH_FN(wrapper_Scalar_ne_));
    m.impl("ne.Tensor",
    TORCH_FN(wrapper_Tensor_ne));
    m.impl("ne.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_ne_out));
    m.impl("ne_.Tensor",
    TORCH_FN(wrapper_Tensor_ne_));
    m.impl("ge.Scalar",
    TORCH_FN(wrapper_Scalar_ge));
    m.impl("ge.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_ge_out));
    m.impl("ge_.Scalar",
    TORCH_FN(wrapper_Scalar_ge_));
    m.impl("ge.Tensor",
    TORCH_FN(wrapper_Tensor_ge));
    m.impl("ge.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_ge_out));
    m.impl("ge_.Tensor",
    TORCH_FN(wrapper_Tensor_ge_));
    m.impl("le.Scalar",
    TORCH_FN(wrapper_Scalar_le));
    m.impl("le.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_le_out));
    m.impl("le_.Scalar",
    TORCH_FN(wrapper_Scalar_le_));
    m.impl("le.Tensor",
    TORCH_FN(wrapper_Tensor_le));
    m.impl("le.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_le_out));
    m.impl("le_.Tensor",
    TORCH_FN(wrapper_Tensor_le_));
    m.impl("gt.Scalar",
    TORCH_FN(wrapper_Scalar_gt));
    m.impl("gt.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_gt_out));
    m.impl("gt_.Scalar",
    TORCH_FN(wrapper_Scalar_gt_));
    m.impl("gt.Tensor",
    TORCH_FN(wrapper_Tensor_gt));
    m.impl("gt.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_gt_out));
    m.impl("gt_.Tensor",
    TORCH_FN(wrapper_Tensor_gt_));
    m.impl("lt.Scalar",
    TORCH_FN(wrapper_Scalar_lt));
    m.impl("lt.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_lt_out));
    m.impl("lt_.Scalar",
    TORCH_FN(wrapper_Scalar_lt_));
    m.impl("lt.Tensor",
    TORCH_FN(wrapper_Tensor_lt));
    m.impl("lt.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_lt_out));
    m.impl("lt_.Tensor",
    TORCH_FN(wrapper_Tensor_lt_));
    m.impl("take",
    TORCH_FN(wrapper__take));
    m.impl("take.out",
    TORCH_FN(wrapper_out_take_out));
    m.impl("index_select",
    TORCH_FN(wrapper__index_select));
    m.impl("index_select.out",
    TORCH_FN(wrapper_out_index_select_out));
    m.impl("masked_select",
    TORCH_FN(wrapper__masked_select));
    m.impl("masked_select.out",
    TORCH_FN(wrapper_out_masked_select_out));
    m.impl("nonzero",
    TORCH_FN(wrapper__nonzero));
    m.impl("nonzero.out",
    TORCH_FN(wrapper_out_nonzero_out));
    m.impl("gather",
    TORCH_FN(wrapper__gather));
    m.impl("gather.out",
    TORCH_FN(wrapper_out_gather_out));
    m.impl("addcmul",
    TORCH_FN(wrapper__addcmul));
    m.impl("addcmul.out",
    TORCH_FN(wrapper_out_addcmul_out));
    m.impl("addcmul_",
    TORCH_FN(wrapper__addcmul_));
    m.impl("addcdiv",
    TORCH_FN(wrapper__addcdiv));
    m.impl("addcdiv.out",
    TORCH_FN(wrapper_out_addcdiv_out));
    m.impl("addcdiv_",
    TORCH_FN(wrapper__addcdiv_));
    m.impl("triangular_solve",
    TORCH_FN(wrapper__triangular_solve));
    m.impl("triangular_solve.X",
    TORCH_FN(wrapper_X_triangular_solve_out));
    m.impl("symeig",
    TORCH_FN(wrapper__symeig));
    m.impl("symeig.e",
    TORCH_FN(wrapper_e_symeig_out));
    m.impl("svd",
    TORCH_FN(wrapper__svd));
    m.impl("svd.U",
    TORCH_FN(wrapper_U_svd_out));
    m.impl("cholesky",
    TORCH_FN(wrapper__cholesky));
    m.impl("cholesky.out",
    TORCH_FN(wrapper_out_cholesky_out));
    m.impl("qr",
    TORCH_FN(wrapper__qr));
    m.impl("qr.Q",
    TORCH_FN(wrapper_Q_qr_out));
    m.impl("erfinv",
    TORCH_FN(wrapper__erfinv));
    m.impl("erfinv.out",
    TORCH_FN(wrapper_out_erfinv_out));
    m.impl("erfinv_",
    TORCH_FN(wrapper__erfinv_));
    m.impl("sign",
    TORCH_FN(wrapper__sign));
    m.impl("sign.out",
    TORCH_FN(wrapper_out_sign_out));
    m.impl("sign_",
    TORCH_FN(wrapper__sign_));
    m.impl("atan2",
    TORCH_FN(wrapper__atan2));
    m.impl("atan2.out",
    TORCH_FN(wrapper_out_atan2_out));
    m.impl("atan2_",
    TORCH_FN(wrapper__atan2_));
    m.impl("fmod.Scalar",
    TORCH_FN(wrapper_Scalar_fmod));
    m.impl("fmod.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_fmod_out));
    m.impl("fmod_.Scalar",
    TORCH_FN(wrapper_Scalar_fmod_));
    m.impl("fmod.Tensor",
    TORCH_FN(wrapper_Tensor_fmod));
    m.impl("fmod.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_fmod_out));
    m.impl("fmod_.Tensor",
    TORCH_FN(wrapper_Tensor_fmod_));
    m.impl("remainder.Scalar",
    TORCH_FN(wrapper_Scalar_remainder));
    m.impl("remainder.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_remainder_out));
    m.impl("remainder_.Scalar",
    TORCH_FN(wrapper_Scalar_remainder_));
    m.impl("remainder.Tensor",
    TORCH_FN(wrapper_Tensor_remainder));
    m.impl("remainder.Tensor_out",
    TORCH_FN(wrapper_Tensor_out_remainder_out));
    m.impl("remainder_.Tensor",
    TORCH_FN(wrapper_Tensor_remainder_));
    m.impl("min",
    TORCH_FN(wrapper__min));
    m.impl("max",
    TORCH_FN(wrapper__max));
    m.impl("maximum",
    TORCH_FN(wrapper__maximum));
    m.impl("maximum.out",
    TORCH_FN(wrapper_out_maximum_out));
    m.impl("minimum",
    TORCH_FN(wrapper__minimum));
    m.impl("minimum.out",
    TORCH_FN(wrapper_out_minimum_out));
    m.impl("sort",
    TORCH_FN(wrapper__sort));
    m.impl("sort.values",
    TORCH_FN(wrapper_values_sort_out));
    m.impl("sort.stable",
    TORCH_FN(wrapper_stable_sort));
    m.impl("sort.values_stable",
    TORCH_FN(wrapper_values_stable_sort_out));
    m.impl("topk",
    TORCH_FN(wrapper__topk));
    m.impl("topk.values",
    TORCH_FN(wrapper_values_topk_out));
    m.impl("all",
    TORCH_FN(wrapper__all));
    m.impl("all.all_out",
    TORCH_FN(wrapper_all_out_all_out));
    m.impl("any",
    TORCH_FN(wrapper__any));
    m.impl("any.all_out",
    TORCH_FN(wrapper_all_out_any_out));
    m.impl("pow.Tensor_Tensor",
    TORCH_FN(wrapper_Tensor_Tensor_pow));
    m.impl("pow.Tensor_Tensor_out",
    TORCH_FN(wrapper_Tensor_Tensor_out_pow_out));
    m.impl("pow_.Tensor",
    TORCH_FN(wrapper_Tensor_pow_));
    m.impl("pow.Scalar",
    TORCH_FN(wrapper_Scalar_pow));
    m.impl("pow.Scalar_out",
    TORCH_FN(wrapper_Scalar_out_pow_out));
    m.impl("pow.Tensor_Scalar",
    TORCH_FN(wrapper_Tensor_Scalar_pow));
    m.impl("pow.Tensor_Scalar_out",
    TORCH_FN(wrapper_Tensor_Scalar_out_pow_out));
    m.impl("pow_.Scalar",
    TORCH_FN(wrapper_Scalar_pow_));
    m.impl("normal_",
    TORCH_FN(wrapper__normal_));
    m.impl("normal.Tensor_float",
    TORCH_FN(wrapper_Tensor_float_normal));
    m.impl("normal.Tensor_float_out",
    TORCH_FN(wrapper_Tensor_float_out_normal_out));
    m.impl("normal.float_Tensor",
    TORCH_FN(wrapper_float_Tensor_normal));
    m.impl("normal.float_Tensor_out",
    TORCH_FN(wrapper_float_Tensor_out_normal_out));
    m.impl("normal.Tensor_Tensor",
    TORCH_FN(wrapper_Tensor_Tensor_normal));
    m.impl("normal.Tensor_Tensor_out",
    TORCH_FN(wrapper_Tensor_Tensor_out_normal_out));
    m.impl("alias",
    TORCH_FN(wrapper__alias));
    m.impl("_amp_foreach_non_finite_check_and_unscale_",
    TORCH_FN(wrapper___amp_foreach_non_finite_check_and_unscale_));
    m.impl("_amp_update_scale_",
    TORCH_FN(wrapper___amp_update_scale_));
    m.impl("mse_loss",
    TORCH_FN(wrapper__mse_loss));
    m.impl("mse_loss.out",
    TORCH_FN(wrapper_out_mse_loss_out));
    m.impl("mse_loss_backward",
    TORCH_FN(wrapper__mse_loss_backward));
    m.impl("mse_loss_backward.grad_input",
    TORCH_FN(wrapper_grad_input_mse_loss_backward_out));
    m.impl("nll_loss_forward",
    TORCH_FN(wrapper__nll_loss_forward));
    m.impl("nll_loss_forward.output",
    TORCH_FN(wrapper_output_nll_loss_forward_out));
    m.impl("nll_loss_backward",
    TORCH_FN(wrapper__nll_loss_backward));
    m.impl("nll_loss_backward.grad_input",
    TORCH_FN(wrapper_grad_input_nll_loss_backward_out));
    m.impl("nll_loss2d_forward",
    TORCH_FN(wrapper__nll_loss2d_forward));
    m.impl("nll_loss2d_forward.output",
    TORCH_FN(wrapper_output_nll_loss2d_forward_out));
    m.impl("nll_loss2d_backward",
    TORCH_FN(wrapper__nll_loss2d_backward));
    m.impl("nll_loss2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_nll_loss2d_backward_out));
    m.impl("smooth_l1_loss",
    TORCH_FN(wrapper__smooth_l1_loss));
    m.impl("smooth_l1_loss.out",
    TORCH_FN(wrapper_out_smooth_l1_loss_out));
    m.impl("smooth_l1_loss_backward",
    TORCH_FN(wrapper__smooth_l1_loss_backward));
    m.impl("smooth_l1_loss_backward.grad_input",
    TORCH_FN(wrapper_grad_input_smooth_l1_loss_backward_out));
    m.impl("elu",
    TORCH_FN(wrapper__elu));
    m.impl("elu.out",
    TORCH_FN(wrapper_out_elu_out));
    m.impl("elu_",
    TORCH_FN(wrapper__elu_));
    m.impl("elu_backward",
    TORCH_FN(wrapper__elu_backward));
    m.impl("elu_backward.grad_input",
    TORCH_FN(wrapper_grad_input_elu_backward_out));
    m.impl("hardsigmoid",
    TORCH_FN(wrapper__hardsigmoid));
    m.impl("hardsigmoid.out",
    TORCH_FN(wrapper_out_hardsigmoid_out));
    m.impl("hardsigmoid_",
    TORCH_FN(wrapper__hardsigmoid_));
    m.impl("hardsigmoid_backward",
    TORCH_FN(wrapper__hardsigmoid_backward));
    m.impl("hardsigmoid_backward.grad_input",
    TORCH_FN(wrapper_grad_input_hardsigmoid_backward_out));
    m.impl("hardtanh",
    TORCH_FN(wrapper__hardtanh));
    m.impl("hardtanh.out",
    TORCH_FN(wrapper_out_hardtanh_out));
    m.impl("hardtanh_",
    TORCH_FN(wrapper__hardtanh_));
    m.impl("hardtanh_backward",
    TORCH_FN(wrapper__hardtanh_backward));
    m.impl("hardtanh_backward.grad_input",
    TORCH_FN(wrapper_grad_input_hardtanh_backward_out));
    m.impl("hardswish",
    TORCH_FN(wrapper__hardswish));
    m.impl("hardswish.out",
    TORCH_FN(wrapper_out_hardswish_out));
    m.impl("hardswish_",
    TORCH_FN(wrapper__hardswish_));
    m.impl("hardswish_backward",
    TORCH_FN(wrapper__hardswish_backward));
    m.impl("leaky_relu",
    TORCH_FN(wrapper__leaky_relu));
    m.impl("leaky_relu.out",
    TORCH_FN(wrapper_out_leaky_relu_out));
    m.impl("leaky_relu_",
    TORCH_FN(wrapper__leaky_relu_));
    m.impl("leaky_relu_backward",
    TORCH_FN(wrapper__leaky_relu_backward));
    m.impl("leaky_relu_backward.grad_input",
    TORCH_FN(wrapper_grad_input_leaky_relu_backward_out));
    m.impl("log_sigmoid_forward",
    TORCH_FN(wrapper__log_sigmoid_forward));
    m.impl("log_sigmoid_forward.output",
    TORCH_FN(wrapper_output_log_sigmoid_forward_out));
    m.impl("log_sigmoid_backward",
    TORCH_FN(wrapper__log_sigmoid_backward));
    m.impl("log_sigmoid_backward.grad_input",
    TORCH_FN(wrapper_grad_input_log_sigmoid_backward_out));
    m.impl("rrelu_with_noise",
    TORCH_FN(wrapper__rrelu_with_noise));
    m.impl("rrelu_with_noise.out",
    TORCH_FN(wrapper_out_rrelu_with_noise_out));
    m.impl("rrelu_with_noise_",
    TORCH_FN(wrapper__rrelu_with_noise_));
    m.impl("rrelu_with_noise_backward",
    TORCH_FN(wrapper__rrelu_with_noise_backward));
    m.impl("softplus",
    TORCH_FN(wrapper__softplus));
    m.impl("softplus.out",
    TORCH_FN(wrapper_out_softplus_out));
    m.impl("softplus_backward",
    TORCH_FN(wrapper__softplus_backward));
    m.impl("softplus_backward.grad_input",
    TORCH_FN(wrapper_grad_input_softplus_backward_out));
    m.impl("softshrink",
    TORCH_FN(wrapper__softshrink));
    m.impl("softshrink.out",
    TORCH_FN(wrapper_out_softshrink_out));
    m.impl("softshrink_backward",
    TORCH_FN(wrapper__softshrink_backward));
    m.impl("softshrink_backward.grad_input",
    TORCH_FN(wrapper_grad_input_softshrink_backward_out));
    m.impl("_adaptive_avg_pool2d",
    TORCH_FN(wrapper___adaptive_avg_pool2d));
    m.impl("_adaptive_avg_pool2d_backward",
    TORCH_FN(wrapper___adaptive_avg_pool2d_backward));
    m.impl("_adaptive_avg_pool3d",
    TORCH_FN(wrapper___adaptive_avg_pool3d));
    m.impl("_adaptive_avg_pool3d_backward",
    TORCH_FN(wrapper___adaptive_avg_pool3d_backward));
    m.impl("adaptive_max_pool2d",
    TORCH_FN(wrapper__adaptive_max_pool2d));
    m.impl("adaptive_max_pool2d.out",
    TORCH_FN(wrapper_out_adaptive_max_pool2d_out));
    m.impl("adaptive_max_pool2d_backward",
    TORCH_FN(wrapper__adaptive_max_pool2d_backward));
    m.impl("adaptive_max_pool2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_adaptive_max_pool2d_backward_out));
    m.impl("avg_pool2d",
    TORCH_FN(wrapper__avg_pool2d));
    m.impl("avg_pool2d.out",
    TORCH_FN(wrapper_out_avg_pool2d_out));
    m.impl("avg_pool2d_backward",
    TORCH_FN(wrapper__avg_pool2d_backward));
    m.impl("avg_pool2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_avg_pool2d_backward_out));
    m.impl("avg_pool3d",
    TORCH_FN(wrapper__avg_pool3d));
    m.impl("avg_pool3d.out",
    TORCH_FN(wrapper_out_avg_pool3d_out));
    m.impl("avg_pool3d_backward",
    TORCH_FN(wrapper__avg_pool3d_backward));
    m.impl("avg_pool3d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_avg_pool3d_backward_out));
    m.impl("max_pool2d_with_indices",
    TORCH_FN(wrapper__max_pool2d_with_indices));
    m.impl("max_pool2d_with_indices.out",
    TORCH_FN(wrapper_out_max_pool2d_with_indices_out));
    m.impl("max_pool2d_with_indices_backward",
    TORCH_FN(wrapper__max_pool2d_with_indices_backward));
    m.impl("max_pool2d_with_indices_backward.grad_input",
    TORCH_FN(wrapper_grad_input_max_pool2d_with_indices_backward_out));
    m.impl("max_pool3d_with_indices",
    TORCH_FN(wrapper__max_pool3d_with_indices));
    m.impl("max_pool3d_with_indices.out",
    TORCH_FN(wrapper_out_max_pool3d_with_indices_out));
    m.impl("max_pool3d_with_indices_backward",
    TORCH_FN(wrapper__max_pool3d_with_indices_backward));
    m.impl("max_pool3d_with_indices_backward.grad_input",
    TORCH_FN(wrapper_grad_input_max_pool3d_with_indices_backward_out));
    m.impl("max_unpool2d",
    TORCH_FN(wrapper__max_unpool2d));
    m.impl("max_unpool2d.out",
    TORCH_FN(wrapper_out_max_unpool2d_out));
    m.impl("max_unpool3d",
    TORCH_FN(wrapper__max_unpool3d));
    m.impl("max_unpool3d.out",
    TORCH_FN(wrapper_out_max_unpool3d_out));
    m.impl("reflection_pad2d",
    TORCH_FN(wrapper__reflection_pad2d));
    m.impl("reflection_pad2d.out",
    TORCH_FN(wrapper_out_reflection_pad2d_out));
    m.impl("reflection_pad2d_backward",
    TORCH_FN(wrapper__reflection_pad2d_backward));
    m.impl("reflection_pad2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_reflection_pad2d_backward_out));
    m.impl("replication_pad1d",
    TORCH_FN(wrapper__replication_pad1d));
    m.impl("replication_pad1d.out",
    TORCH_FN(wrapper_out_replication_pad1d_out));
    m.impl("replication_pad1d_backward",
    TORCH_FN(wrapper__replication_pad1d_backward));
    m.impl("replication_pad1d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_replication_pad1d_backward_out));
    m.impl("replication_pad2d",
    TORCH_FN(wrapper__replication_pad2d));
    m.impl("replication_pad2d.out",
    TORCH_FN(wrapper_out_replication_pad2d_out));
    m.impl("replication_pad2d_backward",
    TORCH_FN(wrapper__replication_pad2d_backward));
    m.impl("replication_pad2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_replication_pad2d_backward_out));
    m.impl("upsample_nearest2d.vec",
    TORCH_FN(wrapper_vec_upsample_nearest2d));
    m.impl("upsample_nearest2d_backward.vec",
    TORCH_FN(wrapper_vec_upsample_nearest2d_backward));
    m.impl("upsample_bilinear2d",
    TORCH_FN(wrapper__upsample_bilinear2d));
    m.impl("upsample_bilinear2d.out",
    TORCH_FN(wrapper_out_upsample_bilinear2d_out));
    m.impl("upsample_bilinear2d_backward",
    TORCH_FN(wrapper__upsample_bilinear2d_backward));
    m.impl("upsample_bilinear2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_upsample_bilinear2d_backward_out));
    m.impl("upsample_nearest2d",
    TORCH_FN(wrapper__upsample_nearest2d));
    m.impl("upsample_nearest2d.out",
    TORCH_FN(wrapper_out_upsample_nearest2d_out));
    m.impl("upsample_nearest2d_backward",
    TORCH_FN(wrapper__upsample_nearest2d_backward));
    m.impl("upsample_nearest2d_backward.grad_input",
    TORCH_FN(wrapper_grad_input_upsample_nearest2d_backward_out));
    m.impl("sigmoid_backward",
    TORCH_FN(wrapper__sigmoid_backward));
    m.impl("sigmoid_backward.grad_input",
    TORCH_FN(wrapper_grad_input_sigmoid_backward_out));
    m.impl("tanh_backward",
    TORCH_FN(wrapper__tanh_backward));
    m.impl("tanh_backward.grad_input",
    TORCH_FN(wrapper_grad_input_tanh_backward_out));
    m.impl("ger",
    TORCH_FN(wrapper__ger));
    m.impl("ger.out",
    TORCH_FN(wrapper_out_ger_out));
};

} // anonymous namespace



namespace xla {



} // namespace xla

} // namespace at
